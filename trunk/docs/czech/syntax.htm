<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!--
Not Automatically generated, changed!:
$Id: syntax.htm,v 1.2 2010/02/27 14:50:13 wilbertd Exp $ 
-->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<title>AviSynth 2 - Basic Syntax</title>
<link rel="stylesheet" type="text/css" href="../avisynth.css">
</head>
<body>
<h2>Zaèínáme<a NAME="Gettingstarted"></a> </h2>
<p>            
              
  V zásadì AviSynth pracuje takto: Nejdøíve vytvoøíte jednoduchý textový dokument se speciálními pøíkazy, nazývaný skript. Tyto pøíkazy 
  se vztahují k jednomu nebo více video-klipùm s filtry, kterými si pøejete klipy 
  zpracovat. Potom spus»te nìkterý videoeditor,&nbsp;jako VirtualDub a otevøete v nìm skriptový soubor. Nyní zaèíná&nbsp;AviSynth 
  pracovat. Otvírá videa, na která se odkazuje skript, upravuje video pomocí 
  filtrù a pøedává výstupní video videoeditoru.&nbsp;Videoeditor ani neví, ¾e AviSynth zpracovává video na 
  pozadí. Naopak, videoeditor si myslí, ¾e pøímo otvírá a filtruje AVI soubor ulo¾ený na 
  pevném disku. 
<p>Ve verzích&nbsp;AviSynth 2 je zavedena nová funkcionalita a èást funkcí 
  je pøetvoøena. Aby byli jasnìji&nbsp;viditelné body týkající se nové funkcionality (zvlá¹tì nedostateènì 
  popsané v døívìj¹í dokumentaci) jsou oznaèeny&nbsp;znaèkou <strong>v2</strong> 
<p>Verze 2.5 obsahuje velké vnitøní zmìny. Pøed jejím pou¾itím si pozornì pøeètìte&nbsp; <A href="twopointfive.htm"
  >AviSynth 2.5</A>     . Odpovídající zmìny
  jsou oznaèeny znaèkou&nbsp; <strong>v2.5</strong>
<h4>Lineární editace:</h4> 
<p>           Nejjednodu¹¹í vìci, které mù¾ete&nbsp;s 
  AviSynthem provádìt jsou operace, které lze provést napø. také ve VirtualDubu. Skripty jsou pro to 
  jednoduché, nemusíte se obávat promìnných a slo¾itých výrazù, pokud to nechcete. 
<p>Pro vyzkou¹ení vytvoøte soubor nazvaný&nbsp; test.avs a vlo¾te do nìj 
  následující jednoduchý textový øádek:
<pre>Version</pre>
<p>Nyní otevøete soubor napøíklad ve&nbsp;Windows Media Playeru a uvidíte 
  10-ti sekundový videoklip ukazující èíslo verze&nbsp;AviSynthu a&nbsp;informaci o autorských právech. 
<p><code>Version</code>    je to co je mo¾né nazvat&nbsp;"zdrojový filtr", 
  rozumí se tím, ¾e vytváøí nový klip místo modifikace stávajícího. První pøíkaz ve skriptu 
  AviSynthu bude v¾dy zdrojový filtr. 
<p>Nyní pøidáme druhý øádek do skriptového souboru, který bude vypadat takto: <br>
  &nbsp; 
<pre>Version
ReduceBy2&nbsp;</pre>
<p>Znovu otevøeme soubor v&nbsp;Media Playeru. Mìli by jste znovu vidìt&nbsp;informaci o 
  verzi, ale v polovièní velikosti proti pøedchozí. <br>
  <code><A href="corefilters/reduceby2.htm">ReduceBy2</A></code>  
    je "transformaèní filtr", to znamená, ¾e 
  bere pùvodní klip a nìjakým zpùsobem ho upraví. Mù¾ete za sebe poskládat nìkolik transformaèních 
  filtrù, stejnì jako ve VirualDubu. <br>
            Pøidejme je¹tì jeden øádek, který vytvoøí 
  stmívání na konci videa. Doplníme do skriptu následující øádek: 
<pre>Version
ReduceBy2
FadeOut(10)</pre>
<p>           Znovu otevøeme soubor. Klip bude 
  stejný prvních 9 vteøin, v poslední vteøinì plynule pøejde do èerna. <br>
  Filtr <A href="corefilters/fade.htm">FadeOut</A>   bere celoèíselný
  argument, který udává èíslo snímkù, ve kterých probìhne stmívání. 
<p>           Trvá hodnì dlouho ne¾ 
  zaène stmívání, a proto vystøihneme zaèátek klipu pro&nbsp;zkrácení èekání pøed stmíváním. <br>
   
      Zahoïme prvních&nbsp;120&nbsp;snímkù, a zachovejme snímky 120-150: <br>
  &nbsp; 
<pre>
Version 
ReduceBy2 
# Odøízne prvních 119 snímkù a nechá snímky 120-150 
# (AviSynth zaèíná èíslování snímkù od 0)
Trim(120,150)
FadeOut(10)</pre>
<p>    V tomto pøíkladu&nbsp;poprvé pou¾íváme komentáø. <br>
         Komentáø zaèíná symbolem #&nbsp;a pokraèuje do konce øádku 
  a je AviSynthem úplnì ignorován.&nbsp; <br>
  Filtr <A href="corefilters/trim.htm">Trim</A>    
               &nbsp;vy¾aduje dva argumenty,
  oddìlené èárkou: první a poslední snímek klipu, který bude zachován. Jestli zadáme&nbsp;0 jako poslední snímek, je to jako&nbsp;"konec
  klipu", tak¾e pokud chcete odstranit prvních 119
snímkù mù¾ete pou¾ít pøíkaz&nbsp;Trim(120,0). 
<p>           Pamatovat si èísla snímkù 
  takovým zpùsobem je otravné. Mnohem snadnìj¹í je&nbsp;otevøít èásteènì&nbsp;vytvoøený skript napø.
  ve VirtualDubu, který zobrazuje èísla daných snímkù. Mù¾ete také pou¾ít filtr&nbsp;
  <A href="corefilters/showframes.htm"> ShowFrameNumber</A>   ,
  který natiskne do snímkù klipu jejich èísla. 
<p>V praxi&nbsp;mnohem více vyu¾ívaným zdrojovým filtrem ne¾ <A href="corefilters/version.htm">Version</A>&nbsp;je <A href="corefilters/avisource.htm">AVISource</A>, který ète&nbsp;AVI soubory (nebo jeden z nìkolika jiných typù  souborù) z disku. Jestli máte
  po ruce nìjaký&nbsp;AVI soubor, mù¾ete zkusit pou¾ít stejné filtry na vá¹ soubor: <br>
  &nbsp; 
<pre>AVISource(&quot;d:\capture.avi&quot;)&nbsp; # uvede se cesta k danému souboru
ReduceBy2
FadeOut(15)
Trim(120,0)</pre>
<p>Dokonce jednoøádkový skript, obsahující pouze jednoøádkový pøíkaz AVISource mù¾e 
  být u¾iteèný&nbsp;pro doplnìní podpory pro&nbsp; AVI soubory &gt;2GB v&nbsp;editorech, které podporují jen soubory&nbsp;&lt;2GB 
  . <br>
<hr>
<h4>Nelineární editace:</h4> 
<p>Nyní se dostáváme k zábavnìj¹í èásti. Vytvoøte&nbsp;AVS&nbsp;soubor s 
  následujícím skriptem: 
<pre>StackVertical(Version, Version)</pre>
<p>    Otevøete jej. Výsledek: Výsledné video má dva stejné øádky s 
  informací o verzi, jeden nad druhým. <br>
  Místo aby 
bral èísla&nbsp;nebo øetìzce&nbsp;jako argumenty, bere&nbsp; <A href="corefilters/stack.htm">StackVertical</A>
             &nbsp;videoklipy jako
  argumenty. V tomto skriptu je filtr&nbsp;Version&nbsp;volán dvakrát. Po ka¾dé se vrací kopie verze. Tyto
  dva klipy se pøedávají filtru <A href="corefilters/stack.htm">StackVertical</A>
   , který je spojí dohromady (bez znalosti jejich pùvodu). 
<p>Jeden z nejpou¾ívanìj¹ích filtrù takového typu je&nbsp; <A href="corefilters/splice.htm">UnalignedSplice</A>  , který 
spojí videoklipy jeden za druhým. Zde je skript, který naèítá tøi&nbsp;AVI&nbsp;soubory (které mohou být vytvoøeny&nbsp;jako AVI_IO)
  a spojuje je dohromady. Obrácené lomítko znamená, ¾e&nbsp;funkce pokraèuje na dal¹ím øádku. 
<pre>UnalignedSplice(AVISource(&quot;d:\capture.00.avi&quot;), \
  AVISource(&quot;d:\capture.01.avi&quot;), \
  AVISource(&quot;d:\capture.02.avi&quot;))</pre>
<p>Oba filtry&nbsp; <A href="corefilters/stack.htm">StackVertical</A> &nbsp;i
  <A href="corefilters/splice.htm">UnalignedSplice</A>  mohou&nbsp;mít
  minimálnì dva a maximálnì ¹estnáct argumentù. <br>Mù¾ete 
pou¾ívat&nbsp;operátor <code>+</code>   &nbsp;jako zkratku pro&nbsp;
  <A href="corefilters/splice.htm">UnalignedSplice</A>. 
<p>    Napøíklad, tento skript provede to samé jako pøedchozí: 
<pre>AVISource(&quot;d:\capture.00.avi&quot;) + \
  AVISource(&quot;d:\capture.01.avi&quot;) + \
  AVISource(&quot;d:\capture.02.avi&quot;)</pre>
<p>         Nyní pøedpokládejme, ¾e 
  zachytáváte pomocí videoeditoru&nbsp;video ve&nbsp;více AVI segmentech, ale audio se ukládá v oddìleném WAV souboru. <br>Mù¾eme
  v¹e znovu spojit?&nbsp; Va¹e volba je: 
<pre>AudioDub(AVISource(&quot;d:\capture.00.avi&quot;) + \
  AVISource(&quot;d:\capture.01.avi&quot;) + \
  AVISource(&quot;d:\capture.02.avi&quot;), \
  WAVSource(&quot;d:\audio.wav&quot;))</pre>
<hr>
<h2><a NAME="Syntax"></a>Syntaxe </h2>
<h4>Výrazy:</h4> 
<p>      Skript&nbsp;AviSynthu obsahuje mno¾ství øádkù&nbsp;údajù takovéhoto typu: 
  &nbsp; 
<pre>variable_name = expression</pre>
<p>V tomto pøíkladu je&nbsp;vyhodnocen výraz expression&nbsp;a výsledek je zapsán do promìnné&nbsp;variable_name. 
<p> Velmi dùle¾itá je bì¾ná zkrácená forma pøíkazu: 
<pre>expression</pre>
<p> V&nbsp;tomto pøípadì probíhá vyhodnocení&nbsp;expression a výsledek se pøiøadí 
  speciální promìnné&nbsp;klipu <var>last</var>. <br>
    Je
    to stejné jako: 
<pre>last = expression</pre>
<p>   Konec skriptu èasto vypadá takto: 
<pre>return expression</pre>
<p>       Zde probíhá vyhodnocení a jeho výsledek je 
  pou¾it jako "vrácená hodnota" skriptu - to je videoklip, který&nbsp;zobrazí videoeditor, ve kterém otvíráme AVS soubor. 
<p>Jestli pøíkaz&nbsp;"return" není&nbsp;výslovnì uveden, vrátí skript&nbsp;na konci své práce klip&nbsp; <var>last</var>&nbsp;pou¾itý jako&nbsp;"vrácená hodnota" ("return value").</p>
<p>      Základní&nbsp;forma výrazu, který&nbsp;vyvolá funkci je:&nbsp; 
<pre>Function(args)</pre>
<p>   Funkce&nbsp;pro klipy v¾dy produkují nový videoklip&nbsp;a nikdy nemodifikují 
  stávající, <br>
  Args je 
seznam argumentù funkce&nbsp;oddìlených èárkou. Seznam mù¾e být prázdný&nbsp;(rozumí se tím, ¾e 
  v¹echny nebo nìkteré argumenty mohou být volitelné - nepovinné). 
<p>   Jestli funkce filtru oèekává videoklip jako svùj první argument 
  a tento argument není uveden, pak bude pou¾it klip&nbsp;ze speciální promìnné&nbsp; <var>last</var> 
    . 
<p>Filtry AviSynthu&nbsp;mohou brát také jmenné argumenty. Jmenné argumenty mohou být ukázány 
  v libovolném poøadí, <br>
  a filtr bude&nbsp;vybírat pøednastavené (default) hodnoty&nbsp;pro v¹echny vynechané argumenty (jmenné 
  argumenty jsou v¾dy volitelné-nepovinné). <br>
  To&nbsp;pomáhá u urèitých filtrù podstatnì zjednodu¹it práci s nimi. 
<pre> Mù¾ete napsat

Subtitle(&quot;Hello, World!&quot;, text_color=$00FF00, x=100, y=200) 

namísto

Subtitle(&quot;Hello, World!&quot;, 100, 200, 0, 999999, &quot;Arial&quot;, 24, $00FF00)</pre>
<p>Alternativní syntaxe (nazývaná "OOP notation") pro klipové funkce je:&nbsp; 
<pre>expression.Function(args)

napø.:
Version.ReduceBy2.FadeOut(15)</pre>
<p>To je ekvivalentní k 
<pre>Function(expression, args)

napø.:
FadeOut(15, ReduceBy2(Version))</pre>
<p>a rozumí se tím pou¾ití funkce&nbsp; <code>Function</code>&nbsp;&nbsp;na <code>expression</code>. <br>
      Jednou z&nbsp;nevýhod OOP notation je mo¾nost jejího vyu¾ití pouze pro filtry 
  s jediným argumentem typu klip, a ne pro filtry s&nbsp;nìkolika argumenty. 
<p>V¹echny funkce&nbsp;AviSynthu&nbsp;vytváøí urèitý poèet snímkù s urèitou frekvencí snímkù (framerate), 
  dokonce i kdy¾ výraz vypadá velmi slo¾itì. <br>
      AviSynth po pøeètení skriptu ví jakou délku bude mít výstupní 
  klip, jakou bude mít frekvenci snímkù a posloupnost v¹ech vstupních snímkù <br>
  To v¹e se vyhodnocuje pøi otevøení skriptu.&nbsp;V dobì zpracování se pøi vy¾ádání 
  snímku provádí&nbsp;pouze&nbsp;skuteèné filtrování. <br>
<hr>
<p><b>Komentáøe</b>: AviSynth ignoruje jakýkoliv text&nbsp;následující za symbolem # a¾ do 
  konce øádku:
<pre># komentáø</pre>
<p>Ve&nbsp;
<em>v2.58</em> je mo¾né pøidat&nbsp;blok a&nbsp;vlo¾ený blok&nbsp;komentáøù
následujícím zpùsobem:
<pre># blok komentáøe:
/* 
komentáø 1
komentáø 2
*/</pre>
<pre># vlo¾ený blok komentáøù: 
[* [* smysluplný pøíklad s pozdìj¹ím následováním :) *] *]</pre>

<p>AviSynth ignoruje cokoliv od slova <code>__END__</code>&nbsp;(se dvìma podtr¾ítky) 
do konce&nbsp;skriptového souboru.&nbsp;Mù¾e to být pou¾ito pro vypnutí&nbsp;nìkterých posledních pøíkazù&nbsp;ve skriptu.
</p>
<pre>Version()
__END__
ReduceBy2() 
Výsledek není zmen¹ený a my sem mù¾eme psát jakýkoliv text
</pre>
 
<p><b>Ignorování velkých-malých písmen</b>: aViSouRCe znamená to samé jako AVISource. 
<p><b>Pokraèování&nbsp;</b> na 
následujícím øádku nebo pokraèování    z pøedchozího øádku: \ 
 
<pre>Subtitle (&quot;Test-Text&quot;)

Subtitle ( \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Test-Text&quot;)

Subtitle (&nbsp;
       \ &quot;Test-Text&quot;)</pre>
<p> 
<hr>
<h4>Promìnné:</h4> 
<p>     Jména promìnných mohou mít délku 50 znakù (ve skuteènosti&nbsp;více ne¾ 4000 znakù&nbsp;Avisynth
<em>v2.56</em> ) a    mohou obsahovat 
  (anglická) písmena, èísla a podtr¾ítka (_), ale ¾ádné jiné znaky. Jméno nemù¾e zaèínat èíslem.
<p>Smíte&nbsp;pou¾ít znaky&nbsp;z kódu va¹eho jazykového 
  systému&nbsp;(lokálnì) v øetìzcích (strings) a&nbsp;názvech souborù&nbsp;(pouze ANSI 8 bit, ne Unicode).</p> 
 
<p>Mohou být pou¾ity následující typy promìnných: 
<p><var>clip</var> :&nbsp;video klip 
          obsahující video a 
  /&nbsp;nebo audio. Nejménì jedna promìnná musí být pro skriptem pou¾ita a vrácena. <br>
  <var>string</var>          
         : 
  øetìzec&nbsp;- uzavøený v&nbsp;"uvozovkách" nebo v trojitých&nbsp;uvozovkách jako zde """tento pøípad""". 
  Textový&nbsp;øetìzec mù¾e obsahovat libovolné znaky&nbsp;kromì&nbsp;uvozovek nebo dvojitého apostrofu.&nbsp;Pokud potøebujete vlo¾it do&nbsp;øetìzce uvozovky pou¾ijte trojité uvozovky:
<pre>Subtitle (&quot;&quot;&quot;Tohle zobrazí &quot;hello world&quot; v uvozovkách&quot;&quot;&quot;)</pre>
<p><var>int:</var> celoèíselné - vstupuje se jako&nbsp;øetìzec èísel, volitelnì s&nbsp;+&nbsp;nebo 
  -&nbsp;na zaèátku. <br>
  <var>float:</var> 
desetinné - vstupuje se 
jako øada èísel s desetinnou 
  teèkou (.) mezi èíslicemi, a&nbsp;doplòuje se volitelnì +&nbsp;nebo -.&nbsp;Napøíklad s&nbsp; +1.&nbsp;se zachází jako&nbsp;s èíslem s desetinnou 
  teèkou. <br>
  <var>val:</var>       typ argumentu funkce pro který je jedno 
  jestli je hodnota&nbsp;int&nbsp;nebo float <br>
  <var>bool</var>: logická - 
mù¾e být pravda TRUE&nbsp;nebo le¾ FALSE <br>
  <var>hexadecimal numbers</var>:&nbsp;zadává se 
  s pøedcházejícím znakem $. Tato promìnná je&nbsp;celoèíselná (integer). Nìkteré filtry vyu¾ívají takové oznaèení 
  pro specifikování barev. Napøíklad, $FF8800 je tmavì oran¾ová. 
<p><var>global</var>: 
definuje&nbsp;globální promìnnou, která mù¾e být vyu¾ívána 
  v¹emi&nbsp;u¾ivatelem&nbsp;definovanými (user-defined) funkcemi&nbsp;stejnì jako i základním skriptem.
<p> Zde je jiná verze døíve uvedeného pøíkladu, která je ovladatelnìj¹í a 
  snadnìj¹í pro pochopení: 
<pre>a = AVISource(&quot;d:\capture.00.avi&quot;)
b = AVISource(&quot;d:\capture.01.avi&quot;)
c = AVISource(&quot;d:\capture.02.avi&quot;)
sound_track = WAVSource(&quot;d:\audio.wav&quot;)

AudioDub(a+b+c, sound_track)</pre>
<hr>
<h2> 
Barvy 
<a name="Colors"></a></h2>
<p>V nìkterých filtrech&nbsp;(BlankClip, Letterbox, AddBorders a FadeXXX) mù¾e být
zadán argument barvy. V ka¾dém pøípadì má být zadán v RGB formátu, dokonce i kdy¾ je
formát barev vstupního klipu YUV. Parametr mù¾e být zadán jak v
¹estnáctkovém tak i v desítkovém tvaru.&nbsp;V ¹estnáctkovém tvaru vypadá následovnì: první dvì&nbsp;cifry urèují kanál èervené
barvy R, dal¹í dvì zelený kanál&nbsp;G a poslední dvì modrý kanál B. Pøed
¹estnáctkovým èíslem musí být symbol $. V desítkovém tvaru je èíslo následující: hodnota
èerveného kanálu je&nbsp;násobena èíslem 65536&nbsp;(2 na 16), hodnota zeleného kanálu je násobena 256 (2na
8) a oba&nbsp;dva výsledné produkty jsou doplnìny do hodnoty modrého kanálu.
<p> 
Uka¾me si pøíklad. Hnìdá barva se zadává&nbsp;R= $A5 
(165), G= 
    $2A (42), B= 
      $2A (42). 
Takovým zpùsobem dá&nbsp;<code>BlankClip(color=   
      $A52A2A)</code>&nbsp;hnìdý snímek. Pøevedení do
desítkové èíselné soustavy&nbsp;(pamatujme, ¾e&nbsp;A=10, B=11, C=12, D=14, E=14, F=15)&nbsp;nám dá&nbsp;

<pre>R = $A5 = 10*16^1 +  5*16^0 = 165
G = $2A =  2*16^1 + 10*16^0 =  42
B = $2A =  2*16^1 + 10*16^0 =  42

165*65536 + 42*256 + 42 = 10824234</pre>
<p> 
   Takovým zpùsobem, pro vytvoøení hnìdého snímku v desítkové soustavì&nbsp;pou¾ije
<code>BlankClip(color=10824234)</code>.
<p>Bì¾ná pøednastavení barev&nbsp;najdete v souboru&nbsp; <var>colors_rgb.avsi</var>,&nbsp;který by mìl 
být ve va¹í slo¾ce&nbsp;autonaèítaných pluginù&nbsp;(podívejte se do souboru&nbsp;na seznam 
pøednastavení).&nbsp;Proto <code>BlankClip(color=color_brown)</code>&nbsp;dává stejné hnìdé snímky.</p>
<p> 
V¹imnìte si, ¾e èerná&nbsp;RGB=$000000 bude pøevedena do&nbsp;Y= 16,U=V=  
   128 pokud je barevný formát vstupního videa&nbsp;YUV, proto¾e je pou¾it&nbsp;výchozí
(defaultní)&nbsp;pøevod barev&nbsp;RGB [0,255] -&gt; YUV [16,235]. 
<hr>
<h2><a NAME="Operators"></a>Operátory </h2>
<p>Pro v¹echny typy promìnných&nbsp;(clip, int, float, string, bool) se kterými lze provádìt operace&nbsp;lze pou¾ít tyto operátory: <br>
  <code>==</code>&nbsp;je rovno<br>
  <code>!=</code>&nbsp;není&nbsp;rovno&nbsp;
<p>Pro èíselné typy (int, float): <br>
  <code>+&nbsp; </code>pøidat <br>
  <code>-&nbsp; </code>odeèíst <br>
  <code>*&nbsp; </code>násobit <br>
  <code>/&nbsp; </code>dìlit <br>
  <code>%&nbsp; </code>zbytek po 
dìlení&nbsp; <br>
  <code>&gt;=</code>&nbsp; vìt¹í nebo rovno&nbsp; <br>
  <code>&lt;=</code>&nbsp; men¹í nebo rovno&nbsp; <br>
  <code>&lt;&nbsp; </code>men¹í ne¾&nbsp; <br>
  <code>&gt;&nbsp; </code>vìt¹í ne¾&nbsp; </p>
 AviSynth v døívìj¹ích verzích zpracovával výrazy zprava doleva, co¾ vedlo k
neoèekávaným výsledkùm: 
<pre>a = 10 - 5 - 5
výsledek byl 10 - (5 - 5) = 10 
místo (10 - 5) - 5 = 0 !</pre>
    
  Tento nedostatek byl opraven!&nbsp;Od verze&nbsp;v2.53 se zpracovávají zleva doprava také
násobení a dìlení (namísto zprava doleva).
<p>Pro øetìzcový typ: <br>
  <code>+&nbsp; </code>pøidat <br>
  <code>&gt;=</code>&nbsp; vìt¹í nebo rovno ne¾ (nerozli¹uje malá a velká písmena) <br>
  <code>&lt;=</code>&nbsp; men¹í 
nebo rovno ne¾ (nerozli¹uje malá a velká písmena) <br>
  <code>&lt;&nbsp; </code>men¹í ne¾ (nerozli¹uje malá a velká písmena) <br>
  <code>&gt;&nbsp; </code>vìt¹í 
ne¾&nbsp;(nerozli¹uje malá a velká písmena) 
<p> Pro klipy: <br>
  <code>+ </code>  stejné jako funkce <code>UnalignedSplice</code> <br>
  <code>++</code>   stejné jako funkce <code>AlignedSplice</code> 
<p>Pro logické (pravda/le¾ - true/false):<br>
<code>||</code>&nbsp;nebo (or)&nbsp; <br>
  <code>&amp;&amp;</code> a (and) <br>
  <code>?:</code> podmínìné vyplnìní 
kódu&nbsp;(operátor jazyka C)&nbsp; 
<pre>b = (a==true)  ?  1 : 2 

To znamená jako by v pseudo-basic:

if (a=true) then b=1 else b=2&nbsp;</pre>
<hr>
<h2><a NAME="ScriptFunctions"></a>Skriptové Funkce </h2>
<p>   Vstupní a výstupní hodnoty tìchto funkcí nejsou klipy, ale nìkteré dal¹í 
  promìnné pou¾ité ve skriptu. 
<h4>Numerické funkce:</h4>
<table BORDER =1 WIDTH="95%">
  <tr> 
        <td WIDTH="62%"><code>Max(<var>int, int[, ...]</var>)</code> / <code>Max(<var>float, float[, ...]</var>)</code>
	      : Maximální hodnota&nbsp;øady èísel.</td>
    <td WIDTH="40%"><code>Max</code> (1, 2) = 2<br>
      <code>Max</code> (5, 3.0, 2) = 5.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Min(<var>int, int[, ...]</var>)</code> / <code>Min(<var>float, float[, ...]</var>)</code>
	      : Minimální hodnota&nbsp;øady èísel.</td>
    <td WIDTH="40%"><code>Min</code> (1, 2) = 1<br>
      <code>Min</code> (5, 3.0, 2) = 2.0</td>
  </tr>
  <tr>
    <td WIDTH="62%"><code>MulDiv(<var>int, int, int</var>)</code> 
        : (m*n+d/2)/d&nbsp;s 64 bitovým mezivýsledkem.</td>
    <td WIDTH="40%"><code>MulDiv</code> (1, 1, 2) = 1<br>
      <code>MulDiv</code> (2, 3, 2) =                                                                                                                                                                                                         3</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Floor(<var>float</var>)</code>: pøevádí z float&nbsp;do int (zaokrouhlení dolù).</td>
    <td WIDTH="40%"><code>Floor</code> (1.2) = 1<br>
      <code>Floor</code> (1.6) = 1<br>
      <code>Floor</code> (-1.2) = -2<br>
      <code>Floor</code> (-1.6) =                                                                       -2</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Ceil</code> (<var>float</var>): 
      pøevádí z float&nbsp;do int 
      (zaokrouhlení nahoru).</td>
    <td WIDTH="40%"><code>Ceil</code> (1.2) = 2.0<br>
      <code>Ceil</code> (1.6) = 2.0<br>
      <code>Ceil</code> (-1.2) = -1<br>
      <code>Ceil</code> (-1.6) = -1</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Round</code> (<var>float</var>): 
      pøevádí z float&nbsp;do int (zaokrouhlení 
      podle pravidel).</td>
    <td WIDTH="40%"><code>Round</code> (1.2) = 1<br>
      <code>Round</code> (1.6) = 2<br>
      <code>Round</code> (-1.2) = -1<br>
      <code>Round</code> (-1.6) =                                                                       -2</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Int</code> (<var>float</var>): pøevádí z float&nbsp;do int 
      (zahodí údaj za desetinnou teèkou =   
	  round towards zero).</td>
    <td WIDTH="40%"><code>Int</code> (1.2) = 1<br>
      <code>Int</code> (1.6) = 1<br>
      <code>Int</code> (-1.2) = -1<br>
      <code>Int</code> (-1.6) = -1</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Float</code> (<var>int</var>): 
      pøevádí z int do float.</td>
    <td WIDTH="40%"><code>Float</code> (1) = 1.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Frac</code> (<var>float</var>   ):
	Vrací èást za desetinnou teèkou.</td>
    <td WIDTH="40%"><code>Frac</code> (3.7) = 0.7<br>
      <code>Frac</code> (-1.8) = -0.8</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="4"><code>Abs</code> (<var>integer</var>) / <code>Abs</code> 
      (<var>float</var>): Vrací absolutní hodnotu (vrací&nbsp;desetinné
	  pro desetinné,&nbsp;celé&nbsp;pro celé).</td>
    <td WIDTH="40%" HEIGHT="4"><code>Abs</code> (-6) = 6<br>
                               <code>Abs</code> (-1.8) = 1.8</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sign</code> (<var>int</var>) / <code>Sign</code> (<var>float</var>): vrací znak èísla&nbsp;(kladné, nulové 
      nebo záporné ve tvaru 1,&nbsp;0&nbsp;nebo -1).</td>
    <td WIDTH="40%"><code>Sign</code>(-3.5) = -1<br>
      <code>Sign</code>(3.5) = 1<br>
      <code>Sign</code>(0) = 0</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="24"><code>HexValue</code> (<var>string</var>) Vyèíslí
	øetìzec jako ¹estnáctkovou hodnotu.</td>
    <td WIDTH="40%" HEIGHT="24"><code>HexValue</code> ("FF00") = 65280</td>
  </tr>
  <tr> 
    <td COLSPAN="2"></td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sin</code> (<var>float</var> ) Vrací sinus
	argumentu&nbsp;(argument se zadává v radiánech).</td>
    <td WIDTH="40%">    Sin(Pi()/4) = 0.707&nbsp;<br>
    Sin(Pi()/2) = 1.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Cos</code> (<var>float</var> ) Vrací kosinus
	argumentu&nbsp;(argument se zadává v radiánech).</td>
    <td WIDTH="40%">    Cos(Pi()/4) = 0.707&nbsp;<br>
    Cos(Pi()/2) = 0.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Pi</code>       () Vrací
	èíslo "Pí"&nbsp;- konstanta (jako podíl obvodu a prùmìru kru¾nice).</td>
    <td WIDTH="40%">d = Pi() # d == 3.141593</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Log</code> (<var>float</var>   )
	Vrací pøirozený logaritmus argumentu (základ-e).</td>
    <td WIDTH="40%">    Log(1) = 0.0&nbsp;<br>
    Log(10) = 2.30259</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Exp</code> (<var>float</var>   )
	Vrací pøirozený exponent argumentu (základ-e).</td>
    <td WIDTH="40%">    Exp(1) = 2.718282&nbsp;<br>
    Exp(0) = 1.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="24"><code>Pow</code> (<var>float base, float power</var> )
        Vrací&nbsp;základ (první argument - "base" ) umocnìný druhým argumentem.</td>
    <td WIDTH="40%" HEIGHT="24">    Pow(2, 3) = 8&nbsp;<br>
    Pow(3, 2) = 9&nbsp;<br>
    Pow(3.45, 1.75) = 8.7334</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sqrt</code> (<var>float</var>   ) Vrací druhou odmocninu argumentu.</td>
    <td WIDTH="40%">    Sqrt(1) = 1.0&nbsp;<br>
    Sqrt(2) = 1.4142</td>
  </tr>
  <tr> 
    <td COLSPAN="2"></td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Rand</code> (<var>[int max] [, bool scale] [, bool seed]</var>): vrací 
      náhodné celé èíslo mezi 0 a maximem.<br>
       &nbsp;&nbsp;Výchozí (defaults):max&nbsp;=&nbsp;32768, &nbsp;scale&nbsp;=&nbsp;TRUE,
                 &nbsp;seed&nbsp;=&nbsp;FALSE<br>
      &nbsp; Scale = FALSE, modulus mode, (Rand(32768)%limit)<br>&nbsp; Seed = 
      TRUE, vyu¾ívá èas pro   
         zadání poèáteèní hodnoty náhodného generátoru</td>
    <td WIDTH="40%"><code>Rand</code>(100) =  celé èíslo mezi&nbsp;0 a 99,&nbsp;v¹echna
                    èísla jsou stejnì pravdìpodobná.<br>
                    <code>Rand</code>(32767, False) =                               celé èíslo
                    mezi 0 a 32766,&nbsp;s 0 dvakrát pravdìpodobnìj¹í ne¾ ostatní èísla.</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Spline</code> (<var>float X,&nbsp; x1,y1, x2,y2, ...., 
      bool "cubic"</var>}<strong> v2.5</strong>&nbsp; <br>
          Interpoluje hodnotu&nbsp;Y&nbsp;pro bod&nbsp;X pøi vyu¾ívání kontrolních bodù x1/y1,... 
      <br>
          Jsou nutné minimálnì&nbsp;2 x/y-páry.&nbsp; <br>
              Interpolace mù¾e být kubická&nbsp;(výsledkem 
      je spline)&nbsp;nebo lineární&nbsp;(výsledkem je polygon)</td>
    <td WIDTH="40%"><code>Spline</code> (5, 0,0, 10,10, 20,0, false) = 5<br>
      <code>Spline</code> (5, 0,0, 10,10, 20,0, true) = 7</td>
  </tr>
</table>
<h4>Øetìzcové funkce:</h4>
<table BORDER =1 WIDTH="95%">
  <tr> 
    <td WIDTH="53%"><code>UCase</code> (<var>string</var> ): vrací&nbsp;øetìzec ve 
      velkých písmenech</td>
    <td WIDTH="60%"><code>UCase</code> ("AviSynth") = "AVISYNTH"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>LCase</code> (<var>string</var>): vrací øetìzec v 
      malých písmenech</td>
    <td WIDTH="60%"><code>LCase</code> ("AviSynth") = "avisynth"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>RevStr</code> (<var>string</var> ): vrací øetìzec 
      v pozpátku</td>
    <td WIDTH="60%"><code>RevStr</code> ("AviSynth") = "htnySivA"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>StrLen</code> (<var>string</var>  ): vrací 
      délku øetìzce</td>
    <td WIDTH="60%"><code>StrLen</code> ("AviSynth") = 8</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Findstr</code> (<var>string1, string2</var>):<br>
       Vrací 
      pozici&nbsp;øetìzce&nbsp;string2&nbsp;uvnitø string1. Pøi hledání se zohledòují velká a malá písmena.</td>
    <td WIDTH="60%"><code>Findstr</code> ("AviSynth","syn") = 4</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>LeftStr</code> (<var>string, length</var>) / <code>RightStr</code> 
      (<var>string, length</var>):<br>
        vrací levou nebo pravou èást øetìzce dané délky</td>
    <td WIDTH="60%"><code>LeftStr</code> ("AviSynth",3) = "Avi"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>MidStr</code> (<var>string, start [, length]</var>):<br>
          vrací èást øetìzce od 
      pozice start&nbsp;(pro první&nbsp;znak je&nbsp;start=
                1) v 
       délce -poètu znakù- dané parametrem&nbsp;length nebo do konce øetìzce&nbsp;(není-li délka zadaná).</td>
    <td WIDTH="60%"><code>MidStr</code> ("AviSynth",3,2) = "iS"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Chr</code> (<var>int</var>   ): vrací znak podle tabulky&nbsp;znakù ASCII&nbsp; 
      <strong>v2.5</strong></td>
    <td WIDTH="60%"><code>Chr</code>  (34) vrátí symbol uvozovek</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Time</code> (<var>string</var> 
      ): vrací     
       øetìzec se systémovým èasem ve tvaru øetìzce daného formátu <strong>v2.5</strong><br>
    </td>
    <td WIDTH="60%"> Kódy výstupního formátu: <br>
      %a&nbsp;Zkratka dne v týdnu&nbsp; <br>
      %A&nbsp;Celý
      název dne v týdnu&nbsp; <br>
       %b Zkratka mìsíce <br>
      %B&nbsp;Celý název mìsíce&nbsp; <br>
      %c Datum a èas v pøíslu¹ném èasovém pásmu <br>
       %d Den mìsíce jako desítkové èíslo (01 - 31) <br>
      %H Hodina ve&nbsp;24-hodinovém formátu (00 - 23) <br>
      %I&nbsp;Hodina ve&nbsp;12-hodinovém formátu (01 - 12) <br>
      %j Den v roce jako desítkové èíslo (001 - 366) <br>
      %m Mìsíc jako desítkové èíslo (01 - 12) <br>
      %M Minuta jako&nbsp;desítkové èíslo (00 - 59) <br>
       %p Indikátor èasu ve 12-hod. formátu A.M./P.M. <br>
      %S Vteøiny jako desítkové èíslo (00 - 59) <br>
      %U Týden v roce jako desítkové èíslo, s nedìlí jako prvním dnem v týdnu (00 
      - 53) <br>
      %w Den
      v týdnu jako desítkové èíslo (0 - 6; Nedìle je 0) <br>
       %W Týden v roce jako desítkové èíslo, Pondìlí je prvním dnem v týdnu (00 
      - 53) <br>
       %x Datum v místním&nbsp;èasovém pásmu&nbsp; <br>
       %X Èas v místním&nbsp;èasovém pásmu&nbsp; <br>
      %y Rok bez století,&nbsp;jako desítkové èíslo&nbsp;(00 - 99) <br>
      %Y&nbsp;&nbsp;Rok&nbsp;se stoletím,&nbsp;jako desítkové èíslo&nbsp; <br>
      %z, %Z Jméno èasového pásma nebo jeho zkratka; ¾ádné symboly je-li pásmo neznámé 
      <br>
      %% Znak procenta 
      <p>         Znaèka&nbsp;#&nbsp;mù¾e&nbsp;pøedcházet jakýkoliv formátový kód. 
        V daném pøípadì se význam mù¾e mìnit následovnì: 
      <p> %#a, %#A, %#b, %#B, %#p, %#X, %#z, %#Z, %#% znak #&nbsp;je ignorován.&nbsp; 
        <br>
           %#c Pou¾ije se dlouhé místní nastavení data 
        a èasu. Napøíklad: "Úterý,&nbsp;14 Bøezna, 1995, 12:41:29".<br>
          %#x Pou¾ije se dlouhé místní nastavení data.&nbsp; Napøíklad: 
        "Tuesday, March 14, 1995".&nbsp; <br>
         %#d, %#H, %#I, %#j, 
      %#m, %#M, %#S, %#U, %#w, %#W, %#y, %#Y Odstraní&nbsp;úvodní nulu&nbsp;(pokud nìjaká je).</p>
                      
          
    </td>
  </tr>
</table>
<h4>Pøevody (konverze):</h4>
<table BORDER =1 WIDTH="95%">
  <tr> 
    <td width="50%"><code>Value</code> (<var>string</var>   ): 
      Vrací hodnotu øetìzce.</td>
    <td WIDTH="50%"><code>Value</code> ( "-2.7" ) = -2.7</td>
  </tr>
  <tr> 
    <td width="50%"><code>String</code> (<var>float / int / string, format_string</var>
       ): Pøevede èíslo na øetìzec.<br>
      <p>Je-li promìnná typu float&nbsp;nebo 
      integer,&nbsp;pøevede ji na&nbsp;float a pou¾ije pøevod&nbsp;formátového 
      øetìzce&nbsp;<EM><FONT color=#660033>format_string</FONT></EM>         &nbsp; na øetìzec.</p>
      <p>   Syntaxe formátového&nbsp; øetìzce&nbsp;<EM><FONT 
      color=#660033>format_string</FONT></EM>      &nbsp;&nbsp;je následující:</p>
      <p>%[flags][width][.precision]f<br>
    width: minimální ¹íøka (øetìzce se nikdy neoøezává)<br>
    precision: poèet ti¹tìných cifer<br>
  flags:<br>
  <tt>&nbsp;-&nbsp;&nbsp;&nbsp;zarovnání vlevo</tt> 
         (namísto pravého zarovnání)<br>
  <tt>&nbsp;+&nbsp;&nbsp;&nbsp;</tt>v¾dy tisknout 
      (zobrazovat) znak +/-&nbsp;<br>
  <tt>&nbsp;0&nbsp;&nbsp;&nbsp;</tt>vypisovat&nbsp;úvodní nuly<br>
  <tt>&nbsp;'&nbsp;'&nbsp;</tt>tisknut (zobrazovat) mezeru namísto&nbsp;"+"<br>
  <tt>&nbsp;#&nbsp;&nbsp;&nbsp;</tt>v¾dy tisknout (zobrazovat) desetinnou teèku</p>
    </td>
    <td WIDTH="50%">napø. <code>Subtitle</code> ("Vý¹ka&nbsp;snímku je" + <code>String</code> 
      (last.height) )<br>
      <br>
      <code>String</code>(1.23, "%f") =      '1.23'<br>
      <code>String</code>(1.23, "%5.1f") =   '  1.2'<br>
      <code>String</code>(1.23, "%1.3f")  = '1.230'
    </td>
  </tr>
</table>
<h4>Funkce kontroly verze:</h4>
<table BORDER =1 WIDTH="95%">
  <tr> 
    <td WIDTH="50%"><code>VersionNumber</code> ()&nbsp; <br>
    Vrací
    èíslo verze AviSynthu jako desetinné èíslo</td>
    <td WIDTH="50%"><code>VersionNumber</code> () = 2.56</td>
  </tr>
  <tr> 
    <td WIDTH="50%"><code>VersionString</code> () <br>
    Vrací èíslo verze AviSynthu jako&nbsp;øetìzec (první øádek&nbsp;je pou¾it v pøíkazu&nbsp; <code>Version</code> ).</td>
    <td WIDTH="50%"><code>VersionString</code> () = "AviSynth 2.56, build:Oct 28 2005 [18:43:54]" 
      </td>
  </tr>
</table>
<h4>Testovací funkce:</h4> 
<p><code>IsBool(<var>var</var>) </code><br>
  <code>IsInt(<var>var</var>) </code><br>
  <code>IsFloat(<var>var</var>) </code><br>
  <code>IsString(<var>var</var>) </code><br>
  <code>IsClip(<var>var</var>) </code>
<h4>Dal¹í funkce:</h4> 
<p><code>Select</code> (<var>index, item0 [, item1...]</var>): Vrací pozici 
  vybranou podle indexu (0= item0). Pozicí mù¾e být jakákoliv promìnná nebo klip, mohou být dokonce smíchány.<br>
  <code>Defined</code> (<var>var</var> ): Pro zadání volitelných funkcí definovaných 
  u¾ivatelem. <br>
  <code>Default</code> (<var>x, d</var>): Vrací&nbsp;x jestli¾e je urèeno funkcí&nbsp;Defined(x), jinak vrací d. 
  <br>
  <code>Exist</code> (<var>filename</var>): Vrací&nbsp;TRUE&nbsp;nebo FALSE 
  po kontrole zda&nbsp;soubor existuje.<br>
  <code>NOP</code> (): Vrací NULL, pøi 
provádìní operací podmínìného plnìní v ruèním 
  re¾imu pro èleny nevracející ¾ádné hodnoty, jako import a podmínìných konstrukcí bez&nbsp;"else".<br>
  <code>Eval</code> (<var>string</var>),<br>
  <code>Apply</code> (<var>func-string, arg,...</var>): <code>Eval</code> ("f(x)")&nbsp;je ekvivalentní k&nbsp; <code>f(x)</code> co¾ je také 
ekvivalentní k&nbsp; <code>Apply</code> ("f", 
  x)
<pre>Mù¾ete vyu¾ít Eval napøíklad takto:
settings = &quot;352, 288&quot;
Eval( &quot;BicubicResize(&quot; + settings + &quot;)&quot; )</pre>
<p><code>Import</code>(<var>filename</var> ):    plní obsah 
  jiného skriptu AviSynthu&nbsp;(importuje text z jiného skriptu) 
<p>Pro sdìlení o chybách a pøehmatech nìkterých u¾ivatelem zadaných vstupních hodnot, je mo¾né 
  pou¾ít: <br>
  <code>Assert</code>(<var>bool, string error-message</var>) 
<p><code>Try ... Catch</code>   : Toto je funkce provìøující jestli nedojde k 
  chybì:
<pre>Try {
&nbsp; AviSource(&quot;file.avi&quot;)
}
Catch(err_msg) {
&nbsp;&nbsp; Blackness.Subtitle(err_msg)
 }</pre>
<hr>

<h2>Runtime Funkce (Funkce èasového plnìní )<a NAME="RuntimelFunctions"></a></h2>
<p>  Existují&nbsp; <A href="corefilters/conditionalfilter.htm">Podmínìné 
  filtry</A> 
(Conditional filters), které&nbsp;vyhodnocují skripty&nbsp;pøi zpracování snímku&nbsp;a tím vám 
  umo¾òují mìnit promìnné pro&nbsp;rùzné snímky. <br>
   Pro øe¹ení vìt¹iny úloh je nutné vyu¾ívat&nbsp;
  <A href="corefilters/conditionalfilter.htm#RuntimeFunctions">Runtime Funkce</A> (funkce èasového plnìní), které zpracovávají obsah klipu a vrací hodnoty. <strong>v2.5</strong> 
<p>
Zde je jednoduchý pøíklad, vyhodnocující støední hodnotu jasu (luma)&nbsp;u ka¾dého snímku a zobrazující výsledek.

<pre>Version()      # Generuje textový klip 
ConvertToYV12()# Pøevádíme do potøebného formátu YV12 
FadeIn(10)     # vytváøíme zmìnu jasu 
               # vidíme, ¾e se nìco dìje 
               
               # Vyhodnocujeme titulky (...) u ka¾dého snímku 
               # výstup støedního jasu (Luma) je pøeveden na 
               # øetìzec a vlo¾ený ve formì titulkù do vstupního klipu
ScriptClip(&quot; Subtitle(String(AverageLuma())) &quot;)
ConvertToRgb   # sledujeme výsledek v RGB</pre>
<hr>

<h2>Ovládací funkce<a NAME="ControlFunctions"></a> &nbsp; </h2>
<p><code>SetMemoryMax</code> (<var>int</var>       
  ): Nastavuje maximální vyu¾itelnou pamì» (v MB). Nastavení na nulu&nbsp;vrátí aktuální hodnotu&nbsp;Memory Max.<strong> v2, (=0) v2.5.8</strong></p>

<p>V øadì 2.5 je výchozí hodnota Memory Max 25% volné fyzické
  pamìti,&nbsp;s minimem 16MB.&nbsp;Od revize&nbsp;2.5.8 RC4, je výchozí&nbsp;Memory Max také limitováno na 512MB.</p>
<table>
  <tr> 
    <th>Volná pamì»</th>
    <td>&lt;64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>1024</td>
    <td>2048</td>
    <td>3072</td>
  </tr>
  <tr> 
    <th>Výchozí Max v2.5.7 a star¹í:</th>
    <td>16</td>
    <td>32</td>
    <td>64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>768</td>
  </tr>
  <tr> 
    <th>Výchozí Max od v2.5.8 RC4:</th>
    <td>16</td>
    <td>32</td>
    <td>64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>512</td>
  </tr>
</table>
<p>V nìkterých star¹ích verzích je pøednastavená hodnota&nbsp;5MB, co¾ 
  je dost málo. Pokud pozorujete problémy&nbsp;(napø. nízkou rychlost) zkuste nastavit hodnotu aspoò na&nbsp;32MB. 
  Pøíli¹ vysoké hodnoty mohou vést k padání z dùvodu 2GB adresového limitu místa.
  Vrácená hodnota: Skuteèná nastavená hodnota velikosti pamìti.</p> 

<p><code>SetPlanarLegacyAlignment</code> (<var>clip, bool</var>): Nastaví re¾im zarovnání
  planárních snímkù. <strong>v2.5.6</strong></p>
<p>Nìkteré star¹í pluginy nesprávnì rozmis»ují snímky videa v pamìti. Tento speciální filtr
  vynutí rozmístìní planárních snímkù v pamìti tak, aby byly kompatibilní s døívìj¹ími verzemi&nbsp;AviSynthu. Filtr pracuje
  se zásobníkem &nbsp;funkce&nbsp;GetFrame(), tak¾e jeho èinnost se vztahuje na filtry umístìné ve skriptu&nbsp;
  <strong>pøed</strong>&nbsp; 
    ním.</p>

<pre><strong>Pøíklad : Pou¾ití staré verze Mpeg2Source()</strong>
             
LoadPlugin(&quot;...\Mpeg2Decode.dll&quot;) 
Mpeg2Source(&quot;test.d2v&quot;)         # Plugin nesprávnì zadává rozmístìní   
SetPlanarLegacyAlignment(true)  # Nastavujeme správné zarovnání
                                # pro døívìj¹í výrazy
ConvertToYUY2()                 # Výrazy jsou správné do konce
                                # skriptu a mají pokroèilý typ
...                             # zarovnání pamìti.</pre>

<p><code>SetWorkingDir</code> (<var>string</var>   ): Nastavuje 
  pracovní slo¾ku&nbsp;Avisynthu. <strong>v2</strong></p>

<p>  Pou¾ívá se pro snadnìj¹í naètení vstupních klipù, atd. Nemá vliv na auto 
  naèítání pluginù. Vrací 0 pøi&nbsp;úspìchu, jinak vrací &nbsp;-1.</p>

<p><code>global OPT_AllowFloatAudio=True</code>: <strong>v2.57</strong><br>
    Tato&nbsp;mo¾nost povoluje výstupní formát 
audia WAVE_FORMAT_IEEE_FLOAT (s
  desetinnou teèkou).&nbsp;Výchozí je automatický pøevod Float do&nbsp;16 bitového (celoèíselného) audia.</p>

<p><code>global OPT_UseWaveExtensible=True</code>: <strong>v2.58</strong><br>
   Tato mo¾nost zapíná audio výstup
  WAVE_FORMAT_EXTENSIBLE. Výchozí je WAVE_FORMAT_EX.</p>

<p>Poznámka: Výchozí DirectShow komponenta pro .AVS 
soubory, "AVI/WAV&nbsp;File Source ",&nbsp;nesprávnì implementuje WAVE_FORMAT_EXTENSIBLE zpracování,&nbsp;tak¾e mnoho aplikací&nbsp;nemusí
  být schopno&nbsp;detekovat&nbsp;audio stopu. Existují DirectShow&nbsp;ètecí programy tøetích stran, které&nbsp;pracují správnì.&nbsp;Mezisoubory
  zapsané&nbsp;pou¾itím AVIFile&nbsp;rozhraní&nbsp;pro pozdìj¹í DirectShow&nbsp;zpracování&nbsp;budou pracovat správnì, pokud&nbsp;pou¾ijí DirectShow "File Source (async)"
  komponentu&nbsp;nebo ekvivalentní.

<hr>

<h2>Vícevláknové (Multithreading) funkce<a NAME="MultithreadingFunctions"></a></h2>
<ul>
  <li><span style="color: rgb(0, 0, 128); font-weight: bold;">GetMTMode</span> <span>&nbsp;</span>
    | <span>&nbsp;</span> v2.6 <span>&nbsp;</span> | <span>&nbsp;</span> <span style="color: purple; font-weight: bold;">GetMTMode(threads)</span></li>
  <li><span style="color: rgb(0, 0, 128); font-weight: bold;">SetMTMode</span> <span>&nbsp;</span>
    | <span>&nbsp;</span> v2.6 <span>&nbsp;</span> | <span>&nbsp;</span> <span style="color: purple; font-weight: bold;">SetMTMode(mode,
    threads)</span></li>
</ul>
<p>Tyto funkce umo¾òují AviSynthu pou¾ít více ne¾ jedno vlákno pøi práci
filtrù. To je u¾iteèné pokud máte více ne¾ jedno cpu/jádro nebo hyperthreading.
Tato funkce je stále experimentální.</p>
<p><span style="color: purple; font-weight: bold;">GetMTMode</span>(bool
threads):</p>
<p>Pokud je <i>threads</i> nastaveno na true, GetMTMode vrátí poèet pou¾itých vláken, 
jinak je vrácen aktuální re¾im (viz ní¾e). Výchozí je false.</p>
<p><span style="color: purple; font-weight: bold;">SetMTMode</span>(int mode,
int threads):</p>
<p>Umístìte toto do prvního øádku v avs souboru, aby jste zapnuli èasový (to je, ¾e více
ne¾ jeden snímek je zpracován v jednom okam¾iku) multithreading. Pou¾ijte to dále
ve skriptu pro zmìnu re¾imu u filtrù pod ním.</p>
<p><i>mode</i>: Existuje 6 re¾imù 1 a¾ 6. Výchozí je 2.</p>
<ul>
  <li>Mode 1 je nejrychlej¹í, ale pracuje jen s nìkolika filtry.</li>
  <li>Mode 2 by mìl pracovat s vìt¹inou filtrù, ale vy¾ívá více pamìti.</li>
  <li>Mode 3 by mìl pracovat s nìkterými filtry, které nefungují s mode 2 ,
    ale je pomalej¹í.</li>
  <li>Mode 4 je kombinací mode 2 a 3 a mìl by pracovat s je¹tì více filtry, 
  ale je pomalej¹í a vyu¾ívá více pamìti.</li>
  <li>Mode 5 je nejpomalej¹í, ale mìl by pracovat se v¹emi filtry, které nevy¾adují
    lineární frameserving (to je, ¾e snímky pøichází popoøadì (snímek 0,1,2 ...
    poslední).</li>
  <li>Mode 6 je upravený mode 5 , který by mìl být mírnì rychlej¹í.</li>
</ul>
<p><i>threads</i>: Poèet pou¾itých vláken. Nastavte na 0 pro nastavení na poèet
dostupných procesorù. Není mo¾né mìnit poèet vláken jinde ne¾
v prvním SetMTMode. Výchozí je 0.</p>
<p><b>Pøíklad:</b></p>
<pre>SetMTMode(2,0)                      # zapíná multihreading pou¾itím thread = poètu 
                                    # dostupných procesorù a mode 2
<a href="syntax_plugins.htm">LoadPlugin</a>(&quot;...\LoadPluginEX.dll&quot;)  # potøebné pro naètení avisynth 2.0 pluginù
LoadPlugin(&quot;...\DustV5.dll&quot;)        # Naète Pixiedust
<a href="corefilters/import.htm" title="Import">Import</a>(&quot;limitedsharpen.avs&quot;) 
src = <a href="corefilters/avisource.htm" title="AviSource">AviSource</a>(&quot;test.avi&quot;)
SetMTMode(5)                        # zmìní mode na 5 pro øádky ní¾e
src = src.<a href="corefilters/convert.htm" title="ConvertToYUY2">ConvertToYUY2</a>.PixieDust() # Pixiedust potøebuje mode 5 aby fungoval.
SetMTMode(2)                        # zmìna mode zpìt na 2
src.LimitedSharpen()                # proto¾e LimitedSharpen pracuje dobøe s mode 2 
# zobrazení re¾imu mode a poètu pou¾itých vláken 
<a href="corefilters/subtitle.htm" title="Subtitle">Subtitle</a>(&quot;Pocet pouzitych vlaken: &quot; + <a href="syntax_internal_functions_conversion.htm" title="Internal functions/Conversion functions">String</a>(GetMTMode(true))
 \ + &quot; Current MT Mode: &quot; + String(GetMTMode()))</pre>
<hr> 
<h2>Vlastnosti klipu<a NAME="ClipProperties"></a> </h2>
<p>     Tyto funkce berou jako vstup klip, jako výstup vrací 
jeho vlastnosti. 

<table border="1" width="100%">
  <tr>
    <td width="20%"><code>Width</code> (<var>clip</var>)</td>
    <td width="50%">    Vrací ¹íøku klipu v pixelech&nbsp;(typ: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Height</code> (<var>clip</var>)</td>
    <td width="50%">    Vrací vý¹ku klipu v pixelech&nbsp;(typ: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Framecount</code> (<var>clip</var>)</td>
    <td width="50%">      Vrací&nbsp;poèet snímkù&nbsp;klipu (typ: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Framerate</code> (<var>clip</var>)</td>
    <td width="50%">      Vrací&nbsp;poèet snímkù&nbsp;za sekundu klipu (typ:
      float).</td>
  </tr>
  <tr>
    <td width="20%"><code>FramerateNumerator</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Èitatel zlomkového zápisu snímkové 
      frekvence.</td>
  </tr>
  <tr>
    <td width="20%"><code>FramerateDenominator</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Jmenovatel zlomkového zápisu snímkové 
      frekvence.&nbsp;</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiorate</code> (<var>clip</var>)</td>
    <td width="50%">      Vrací vzorkovací frekvenci&nbsp;audia klipu.</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiolength</code> (<var>clip</var>)</td>
    <td width="50%">Vrací poèet vzorkù&nbsp;audia&nbsp;klipu (typ: int). Pamatujte, ¾e je zde mo¾nost&nbsp;pøeteèení u&nbsp;velmi dlouhých&nbsp;klipù ( 2^31&nbsp;vzorkù limit).</td>
  </tr>
  <tr>
    <td width="20%"><code>AudiolengthF</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">        Vrací poèet vzorkù&nbsp;audia&nbsp;klipu
      (typ: float).</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiochannels</code> (<var>clip</var>)</td>
    <td width="50%">    Vrací poèet kanálù audia klipu.</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiobits</code> (<var>clip</var>)</td>
    <td width="50%">   Vrací bitovou hloubku audia klipu.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsAudioFloat</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Vrací&nbsp;true kdy¾ bitová hloubka&nbsp;audia&nbsp;klipu&nbsp;je
      float.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsAudioInt</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Vrací&nbsp;true&nbsp;kdy¾ bitová hloubka&nbsp;audia&nbsp;klipu&nbsp;je
      integer.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB</code> (<var>clip</var>)</td>
    <td width="50%">   Vrací&nbsp;true kdy¾ je klip RGB, jinak false&nbsp;(typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB24</code> (<var>clip</var>)</td>
    <td width="50%">   Vrací&nbsp;true   kdy¾ je klip RGB24, jinak false (typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB32</code> (<var>clip</var>)</td>
    <td width="50%">   Vrací&nbsp;true kdy¾ je klip RGB32, jinak false&nbsp;(typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYUY2</code> (<var>clip</var>)</td>
    <td width="50%">   Vrací&nbsp;true kdy¾ je klip YUY2, jinak false&nbsp;(typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYV12</code> (<var>clip</var>) <strong>v2.51</strong></td>
    <td width="50%">   Vrací&nbsp;true kdy¾ je klip YV12, jinak false&nbsp;(typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYUV</code> (<var>clip</var>) <strong>v2.54</strong> </td>
    <td width="50%">  Vrací&nbsp;true kdy¾ je klip YUV, jinak false (typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsPlanar</code> (<var>clip</var>) <strong>v2.51</strong> </td>
    <td width="50%">Vrací&nbsp;true&nbsp;kdy¾ je&nbsp;barevný formát klipu planární, jinak false (typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsInterleaved</code> (<var>clip</var>) <strong>v2.51</strong> </td>
    <td width="50%">   Vrací&nbsp;true kdy¾ je&nbsp;barevný formát klipu prolínaný, jinak false (typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsFieldBased</code> (<var>clip</var>)</td>
    <td width="50%">&nbsp;</td>
  </tr>
  <tr>
    <td width="20%"><code>IsFrameBased</code> (<var>clip</var>)</td>
    <td width="50%">&nbsp;</td>
  </tr>
  <tr>
    <td width="20%"><code>GetParity</code> (<var>clip, int "n"</var>)</td>
    <td width="50%">Vrací&nbsp;true kdy¾ snímek n 
      (výchozí 0)&nbsp;je horní pole klipu zalo¾eného na polích,&nbsp;nebo
    je to plný snímek&nbsp;s horním polem jako prvním&nbsp;z klipu zalo¾eného na snímcích (typ: bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>HasAudio</code> (<var>clip</var>) <strong>v2.56</strong> </td>
    <td width="50%">   Vrací&nbsp;true kdy¾ má klip audio, jinak false&nbsp;(typ:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>HasVideo</code> (<var>clip</var>) <strong>v2.56</strong> </td>
    <td width="50%">   Vrací&nbsp;true kdy¾ má klip video, jinak false&nbsp;(typ:
      bool).</td>
  </tr>
</table>

<p>
Nezapomeòte: mù¾ete pou¾ít vlastnosti s implicitní (vestavìnou)&nbsp;promìnnou LAST&nbsp;nebo&nbsp;ve variantì&nbsp;OOP-zápisu:
<pre>BilinearResize(Width/2, Height/2)
   je stejné jako 
BilinearResize(Width(Last)/2, Height(Last)/2)  
   je stejné jako
BilinearResize(Last.Width / 2, Last.Height / 2)</pre>
<p> 
<hr>
<h2>U¾ivatelem definované funkce<a NAME="userdefined"></a> &nbsp; </h2>
<p>  Mù¾ete definovat své vlastní funkce. Nejlep¹í to bude&nbsp;vysvìtlit na pøíkladu: <br>
  &nbsp; 
<pre>Function NTSC2PAL( clip c) {
&nbsp;&nbsp;&nbsp; Assert(c.height == 480, \
           &quot;NTSC2PAL: vstupní klip musí mít rozli¹ení 480 øádkù&quot;)
&nbsp;&nbsp;&nbsp; Bob(c, height=576)
&nbsp;&nbsp;&nbsp; return Weave()
}</pre>
<p>Je mo¾né vytvoøit dokonce rekurzivní (zahrnující vlastní výzvu) funkci.&nbsp; <br>
  &nbsp; 
<pre>function TRANSITION(clip clip, int start, int expo, int overlap)
{
   return ( start &gt;= clip.framecount-expo ? 
\      Trim(clip,start,0) : 
\      Dissolve(Trim(clip,start,start+expo-1),
\         TRANSITION(clip,start+expo,expo,overlap),
\         overlap 
\              )
\         )
}</pre>
<p> 
<hr>
<h2>Funkce pro více klipù<a NAME="multiclip"></a>      &nbsp; </h2>
<p>      Jsou nìkteré funkce, které rùznì kombinují práci 
  se dvìma nebo více klipy. Jakým zpùsobem se vytváøí video závisí na konkrétní 
  funkci,&nbsp;a zde je pøehled jaké vlastnosti bude mít výsledný klip. 
<p>     Vstupní klipy musí mít v¾dy stejný formát barev a s 
  výjimkou&nbsp; <i>Layer</i>  - stejné rozmìry.&nbsp; 
<table BORDER =1>
  <tr> 
    <td></td>
    <td> 
      <center>
        <b>snímková 
      frekvence</b>
      </center>
      <CENTER><B>(frame-rate)</B> </CENTER>
    </td>
    <td COLSPAN="2"> 
      <center>
        <b>poèet 
      snímkù</b>
      </center>
    </td>
    <td> 
      <center>
        <b>obsah zvuku</b>
      </center>
    </td>
    <td> 
      <center>
        <b> vzorkovací 
      frekvence&nbsp;zvuku</b>
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>AlignedSplice, UnalignedSplice</b></td>
    <td ROWSPAN="6"> 
      <center>
        první klip
      </center>
    </td>
    <td> 
      <center>
         suma v¹ech klipù
      </center>
    </td>
    <td></td>
    <td> 
      <center>
        viz popis filtru
      </center>
    </td>
    <td ROWSPAN="7"> 
      <center>
        z prvního&nbsp;klipu
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Dissolve</b></td>
    <td> 
      <center>
      <CENTER>suma v¹ech klipù bez pøekrytí</CENTER>
              
      </center>
    </td>
    <td></td>
    <td> 
      <center>
      <CENTER>viz popis filtru</CENTER>
          
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Merge, MergeLuma, MergeChroma, Merge(A)RGB</b></td>
    <td ROWSPAN="2"> 
      <center>
        první klip
      </center>
    </td>
    <td ROWSPAN="5"> 
      <center>
           poslední snímek
      </center>
      <CENTER>krat¹ího klipu&nbsp;</CENTER>
      <CENTER>se opakuje do konce klipu</CENTER>
    </td>
    <td ROWSPAN="5"> 
      <center>
        první klip
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Layer</b></td>
  </tr>
  <tr> 
    <td><b>Subtract</b></td>
    <td ROWSPAN="2"> 
      <center>
        del¹í klip
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>StackHorizontal, StackVertical</b></td>
  </tr>
  <tr> 
    <td><b>Interleave</b></td>
    <td> 
      <center>
         (fps prvního klipu) <br>
        x <br>
         (poèet klipù)
      </center>
    </td>
    <td> 
      <center>
         N x poèet snímkù&nbsp;nejdel¹ího klipu&nbsp;
      </center>
    </td>
  </tr>
</table>
<p>      Jak vidíte funkce nejsou úplnì symetrické, ale berou 
  nìkteré atributy z&nbsp;PRVNÍHO klipu. <br>
<hr>
<h2><a NAME="Plugins"></a>Pluginy </h2>
<p> S tìmito funkcemi mù¾ete pøidat do Avisynthu vnìj¹í funkce. 
<p><code>LoadPlugin</code> (<var>"filename" [, ...]</var>) 
<p>Naèítá jeden nebo více externích pluginù Avisynthu ve formì DLL modulù. <br>
<hr>
<p><code>LoadVirtualDubPlugin</code> (<var>"filename",
"filtername", preroll</var>) 
<p>Tato funkce naèítá pluginy napsané pro 
VirtualDub.&nbsp;"filename" zde znamená jméno&nbsp;.vdf souboru. Po vyvolání této funkce budou filtry VirtualDubu dostupné 
  pro&nbsp;Avisynth&nbsp;pod jménem zadaným&nbsp;ve&nbsp;"filtername". Filtry VirtualDubu&nbsp;podporují pouze RGB32. Pokud se stane, ¾e video 
  bude ve formátu&nbsp;RGB24, pak jej musíte&nbsp;pøevést pomocí&nbsp; <code>ConvertToRGB32</code> (<code>ConvertToRGB</code> 
   &nbsp;nestaèí). 
<p>       
  Výstupní hodnoty nìkterých filtrù závisí na pøedchozích snímcích; pro nì je nutné stanovit pøedbì¾né zpracování údajù pro&nbsp;zaplnìní 
  jejich bufferù&nbsp; a/nebo aktualizování jejich vnitøních promìnných. <br>
<hr>
<p><code>LoadVFAPIPlugin</code> (<var>"filename",
"filtername"</var>)
<p>   Umo¾ní vám vyu¾ít pluginy&nbsp;VFAPI (TMPGEnc importí pluginy).<br>
<hr>

<p>
<code>LoadCPlugin</code> (<var>"filename" [, ...]</var>)<br>
<code>Load_Stdcall_Plugin</code> (<var>"filename" [, ...]</var>)</p>
<p> Naèítá tzv. Avisynth C-pluginy (DLL). <br>
Load_Stdcall_Plugin() je synonymem pro&nbsp;LoadCPlugin().&nbsp;
<br>C-pluginy jsou pluginy 
vytvoøené v jazyce C a vyu¾ívající&nbsp;"AviSynth C API" 
(na rozdíl od obyèejných pluginù Avisynthu, které jsou vytvoøeny v&nbsp;MS 
C++). C-pluginy musí být naèteny pomocí funkcí&nbsp;LoadCPlugin()&nbsp;nebo Load_Stdcall_Plugin().
<p>    Kevin 
vytvoøil&nbsp;LoadCPlugin.dll , pro pøeurèení funkce LoadCPlugin() s cílem podpory&nbsp;C-pluginù zkompilovaných s C subroutine calling sequence, pou¾ijte&nbsp;Load_Stdcall_Plugin() k naètení pluginù se standardním souhlasem výzvy (stdcall) v pøípadì pou¾ití verze od&nbsp;Kevina.
Rada: nechte tyto C-pluginy mimo&nbsp;Va¹i autonaèítací slo¾ku pluginù, vyhnete se tak vá¾ným
problémùm. [<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=58840">discussion</a>]
[<a href="http://kevin.atkinson.dhs.org/avisynth_c/">AVISynth C API (by kevina20723)</a>]</p>
<hr>
<h2>Autonaèítání pluginù a priorita názvù<a NAME="autoloading"></a>    &nbsp; <strong>v2</strong></h2>
<p>Je mo¾né umístit v¹echny soubory pluginù i soubory skriptù s u¾ivalelem definovanými 
  funkcemi nebo (globálními ) promìnnými&nbsp;do slo¾ky, ze které budou v¹echny soubory s pøíponami 
  .AVSI (<strong>v2.08, v2.5</strong>  ,&nbsp;ve verzích&nbsp; <strong>v2.05-2.07</strong> typ byl &nbsp;.AVS&nbsp;) a .DLL naèítány pøi startu, dynamicky se vyprazdòovat a znovu 
  naèítat podle potøeby skriptu. 
<p>      .AVSI skripty v této slo¾ce&nbsp;smí obsahovat 
  pouze definice funkcí a globální promìnné,&nbsp;¾ádné hlavní provádìcí sekce (jinak se mohou 
  objevit chyby), také se nedoporuèuje ukládat&nbsp;jiné soubory do této slo¾ky. 
<p>Cesta k této slo¾ce je uchována v systémovém registru (klíèe registru byly zmìnìny&nbsp;pro <strong>v2.5</strong> 
           ).&nbsp;Dvojklikem na&nbsp;.REG-soubor s následujícími 
  øádky nastaví cestu&nbsp;(samozøejmì je-li uvedena správná cesta): <br>
  &nbsp; 
<pre>REGEDIT4


[HKEY_LOCAL_MACHINE\SOFTWARE\Avisynth]
&quot;plugindir2_5&quot;=&quot;c:\\program files\\avisynth 2.5\\plugins&quot;</pre>
<p>    Poøadí plnìní funkcí se øídí následujícími pravidly: 
<pre>  u¾ivatelem definované funkce (mají v¾dy
   nejvy¹¹í prioritu) plugin-funkce (mají vy¹¹í prioritu
   ne¾ vestavìné funkce, budou nahrazovat vestavìné funkce)
      vestavìné funkce</pre>
<p>V rámci tìchto skupin se bude naèítání tìchto skupin provádìt podle poøadí, (poslední 
  má pøednost), konflikt jmen není chybou. </p>
<h2><a NAME="autoloading_confl"></a>Autonaèítací pluginy a konflikty funkcí
jmen <strong>v2.55</strong> </h2>
<p>Poèínaje verzí&nbsp;v2.55&nbsp;se 
podporuje zápis&nbsp;DLLName_function().&nbsp;Problém
nastává pokud se naèítají dva pluginy rùzných funkcí ale stejných názvù. K vyvolání potøebné
funkce&nbsp;z nich je urèen DLLName_function(). Automaticky generuje 
doplòková jména jak pro auto naèítané pluginy tak i pro pluginy naèítané pomocí
funkce&nbsp;LoadPlugin. </p>
<p><b>Nìkteré pøíklady:</b> </p>
<pre># pou¾ití funkce fielddeinterlace z decomb510.dll
AviSource(&quot;D:\captures\jewel.avi&quot;)
decomb510_fielddeinterlace(blend=false)</pre>
<p>        Pøedpokládá se,
¾e ve slo¾ce autonaèítání jsou pluginy&nbsp;mpeg2dec.dll a mpeg2dec3.dll, a vy chcete naèíst soubor&nbsp;d2v&nbsp;s mpeg2dec.dll
(který produkuje&nbsp;YUY2): </p>
<pre># pou¾ít mpeg2source z mpeg2dec.dll
mpeg2dec_mpeg2source(&quot;F:\From_hell\from_hell.d2v&quot;)</pre>
<p>nebo s pomocí&nbsp;mpeg2dec3.dll (který produkuje YV12): </p>
<pre># pou¾ít mpeg2source z mpeg2dec3.dll
mpeg2dec3_mpeg2source(&quot;F:\From_hell\from_hell.d2v&quot;)</pre>
<p><kbd>$English Date: 2008/12/06 16:37:26 $</kbd></p>
<P><KBD>Èeský pøeklad:12.2.2009</KBD></P>
</body>
</html>

