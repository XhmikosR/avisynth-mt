<html>
<head>
<title>DctFilter</title>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: dctfilter.htm,v 1.1 2004/10/19 21:09:51 alex_e_basta Exp $ 
-->
</head>
<body>
<h1>DctFilter</h1>
<h2>Sommario</h2>
<b>author:</b> Tom Barry
<br><b>version:</b> 0.0.1.4
<br><b>download: </b><a href="http://mywebpages.comcast.net/trbarry/downloads.htm">http://mywebpages.comcast.net/trbarry/downloads.htm</a><br>
<b>category:</b> Misc Plugins<br>
<b>requirements:</b> &nbsp;
<ul>
  <li>YV12 &amp; YUY2 Colorspace ed immagine multipla di 16x16</li>
  <li>SSEMMX support</li>
</ul>
<hr>
<h2>Descrizione</h2>
DctFilter &egrave; un filtro sperimentale che per ogni blocco 8x8 , attua una 
Discrete Cosine Transform (DCT), riduce i valori della frequenza selezionata, 
di seguito rovescia il procedimento con una Inverse Discrete Cosine Transform 
(IDCT). 
<h3>Uso</h3>
<p> In Avisynth </p>
<pre>Avisource(&quot;D:\wherever\myfile.avi&quot;)
DctFilter(1,1,1,1,1,1,.5,0)</pre>
<h3> Parametri</h3>
<p>Ci sono 8 parametri floating point positionali, che devono tutti essere compresi 
  nel range (0.0 &lt;= x &lt;= 1.0). Questi corrispondono ai fattori di scala 
  per le 8 righe e colonne dei blocchi 8x8 DCT . Il parametro pi&ugrave; a sinistra 
  corresponde alla riga superiore, colonna di sinistra. Questo sarebbe il componente 
  DC della trasformazione e dovrebbe sempre essere lasciato = 1.0. </p>
<p>Nell'esempio precedente i componenti ad alta frequenza di ogni riga e colonna 
  saranno azzerati mentre i secondi in ordine di altezza saranno dimezzati. </p>
<p>I parameri di riga e colonna sono moltiplicati fra loro per ottenerelo scale 
  factor per ognuno dei 64 valori presenti nel blocco. In questo modo se il valore 
  in alto a sinistra fosse stato V[0,0], nell'esempio precedente avremmo scalato 
  la riga 6, colonna 6 (V[6,6]) di .5*.5 = .25.</p>
<p>Notre che sebbene i parametri sembrino floating point parms , in realt&agrave; 
  finora hanno una precisione di solo 3 bit sicch&egrave; i valori attuali usati 
  sono solo 0, 1/8, 1/4, 3/8 ... 1.0. Potete specificare qualunque valore, ma 
  questo sar&agrave; arrotondato al valore pi&ugrave; vicino.</p>
<h3> DctFilterD - Nuovo con v 0.0.1.4</h3>
<p>Al suo posto si pu&ograve; usare DctFilterD(DiagCt). Questo funziona in modo 
  simile al precedente, ma azzera il numero DiagCt della diagonale destra pi&ugrave; 
  bassa della DCT, lasciando inalterati gli altri valori . In una matrice 8x8 
  DCT ci son 15 possibile diagonali. (immaginatevi una scacchiera). Il parametro 
  DiagCt deve essere un intero compreso tra 1 e 14 ad indicare quante di queste 
  diagonali devono essere azzerate partendo partendo dall'angolo pi&ugrave; basso 
  a destra.</p>
<h3>Commenti</h3>
<p>Questa nuova funzione DctFilterD(DiagCt) lavora sulle diagonali. E' pi&ugrave; 
  semplice e pu&ograve; sia azzerare che lasciare intatte le diagonali.</p>
<p>In una matrice 8x8 DCT ci son 15 possibile diagonali. (immaginatevi una scacchiera). 
  Sicch&egrave; se si specifica: </p>
<pre>DctFilterD(4)</pre>
<p>le 4 diagonali nell'angolo destro in basso della DCT saranno impostati a 0. 
  Il parametro DiagCt pu&ograve; essere qualunque intero da 1 a 14.</p>
<p>Non l'ho testato molto, ma , analogamente a quanto rilevato in tests sulle 
  matrici di quantizzazione, sembra che se si imposta DiagCt a valori molto alti 
  si cominciano ad avere rumore nei contorni simile al ringing.</p>
<p><kbd>$Date: 2004/10/19 21:09:51 $</kbd></p>
</html>
