<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!--
Not Automatically generated, changed!:
$Id: syntax.htm,v 1.46 2008/12/06 16:37:26 fizick Exp $ 
-->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>AviSynth 2 - Basic Syntax</title>
<link rel="stylesheet" type="text/css" href="../avisynth.css">
</head>
<body>
<h2><a NAME="Gettingstarted"></a>Getting started</h2>
<p>Basically, AviSynth works like this: First, you create a simple text document 
  with special commands, called a script. These commands make references to one 
  or more videos and the filters you wish to run on them. Then, you run a video 
  application, such as VirtualDub, and open the script file. This is when AviSynth 
  takes action. It opens the videos you referenced in the script, runs the specified 
  filters, and feeds the output to video application. The application, however, 
  is not aware that AviSynth is working in the background. Instead, the application 
  thinks that it is directly opening a filtered AVI file that resides on your 
  hard drive. 
<p>There is much new and re-discovered functionality in AviSynth2. To make those 
  items clearly visible (especially when the feature was not well documented in 
  the past) they are marked with <strong>v2</strong> 
<p>The version 2.5 is a major internal upgrade. Read <a href="twopointfive.htm"
  >AviSynth 2.5</a> carefully before you use it. Relevant changes
  are marked with <strong>v2.5</strong>
<h4>Linear Editing:</h4> 
<p>The simplest thing you can do with AviSynth is the sort of editing you can 
  do in VirtualDub. The scripts for this are easy to write because you don't have 
  to worry about variables and complicated expressions if you don't want. 
<p>For testing create a file called test.avs and put the following single line 
  of text in it:
<pre>Version</pre>
<p>Now open this file with e.g. Windows Media Player and you should see a ten-second 
  video clip showing AviSynth's version number and a copyright notice. 
<p><code>Version</code> is what's called a "source filter", meaning that it generates 
  a clip instead of modifying one. The first command in an AviSynth script will 
  always be a source filter. 
<p>Now add a second line to the script file, so that it reads like this: <br>
  &nbsp; 
<pre>Version
ReduceBy2&nbsp;</pre>
<p>Reopen the file in Media Player. You should see the copyright notice again, 
  but now half as large as before. <br>
  <code><a href="corefilters/reduceby2.htm">ReduceBy2</a></code> is a
  "transformation filter," meaning that it takes the previous 
  clip and modifies it in some way. You can chain together lots of transformation 
  filters, just as in VirtualDub. <br>
  Let's add another one to make the video fade to black at the end. Add another 
  line to the script file so that it reads: 
<pre>Version
ReduceBy2
FadeOut(10)</pre>
<p>Now reopen the file. The clip should be the same for the first 9 seconds, and 
  then in the last second it should fade smoothly to black. <br>
  The <a href="corefilters/fade.htm">FadeOut</a> filter takes a numerical
  argument, which indicates the number of frames to fade. 
<p>It takes a long time before the fade starts, so let's trim the beginning of 
  the clip to reduce the wait, and fade out after that. <br>
 Let's discard 
  the first 120 of them, and keep the frames 120-150: <br>
  &nbsp; 
<pre>Version
ReduceBy2
# Chop off the first 119 frames, and keep the frames 120-150
# (AviSynth starts numbering frames from 0)
Trim(120,150)
FadeOut(10)</pre>
<p>In this example we used a comment for the first time. <br>
  Comments start with the # character and continue to the end of the line, and 
  are ignored completely by AviSynth. <br>
  The <a href="corefilters/trim.htm">Trim</a> filter takes two arguments,
  separated by a comma: the first and the last frame to keep from the clip. If
  you put 0 for the last frame, it's the same as "end of clip," so if you only
  want to remove the first 119 frames
you should use Trim(120,0). 
<p>Keeping track of frame numbers this way is a chore. It's much easier to open 
  a partially-completed script in an application like VirtualDub which will
  display the frame numbers for you. You can also use the
  <a href="corefilters/showframes.htm"> ShowFrameNumber</a> filter, which prints
  each frame's number onto the frame itself. 
<p>In practice a much more useful source filter than <a href="corefilters/version.htm">Version</a>
  is <a href="corefilters/avisource.htm">AVISource</a>, which reads in an AVI
  file (or one of several other types of files) from disk.  If you have an AVI
  file handy, you can try applying these same filters to your file: <br>
  &nbsp; 
<pre>AVISource(&quot;d:\capture.avi&quot;)&nbsp; # or whatever the actual pathname is
ReduceBy2
FadeOut(15)
Trim(120,0)</pre>
<p>Even a single-line script containing only the AVISource command can be useful 
  for adding support for &gt;2GB AVI files to applications which only support &lt;2GB 
  ones. <br>
<hr>
<h4>Non-Linear Editing:</h4> 
<p>Now we're getting to the fun part. Make an AVS file with the following script 
  in it: 
<pre>StackVertical(Version, Version)</pre>
<p>Now open it. Result: An output video with two identical lines of version information, 
  one on top of the other. <br>
  Instead of taking numbers or strings as arguments, <a href="corefilters/stack.htm">StackVertical</a>
  takes video clips as arguments. In this script, the Version filter is being
  called twice. Each time, it returns a copy of the version clip. These two
  clips are then given to <a href="corefilters/stack.htm">StackVertical</a>,
  which joins them together (without knowing where they came from). 
<p>One of the most useful filters of this type is <a href="corefilters/splice.htm">UnalignedSplice</a>,
  which joins video clips end-to-end. Here's a script which loads three AVI
  files (such as might be produced by AVI_IO) and concatenates them together. 
<pre>UnalignedSplice(AVISource(&quot;d:\capture.00.avi&quot;), \
  AVISource(&quot;d:\capture.01.avi&quot;), \
  AVISource(&quot;d:\capture.02.avi&quot;))</pre>
<p>Both <a href="corefilters/stack.htm">StackVertical</a> and
  <a href="corefilters/splice.htm">UnalignedSplice</a> can take as few as two
  arguments or as many as sixty. <br>
  You can use the <code>+</code> operator as a shorthand for
  <a href="corefilters/splice.htm">UnalignedSplice</a>. 
<p>For example, this script does the same thing as the previous example: 
<pre>AVISource(&quot;d:\capture.00.avi&quot;) + \
  AVISource(&quot;d:\capture.01.avi&quot;) + \
  AVISource(&quot;d:\capture.02.avi&quot;)</pre>
<p>Now let's suppose you're capturing with an application that also saves the 
  video in multiple AVI segments, but puts the audio in a separate WAV file. <br>
  Can we recombine everything? You bet: 
<pre>AudioDub(AVISource(&quot;d:\capture.00.avi&quot;) + \
  AVISource(&quot;d:\capture.01.avi&quot;) + \
  AVISource(&quot;d:\capture.02.avi&quot;), \
  WAVSource(&quot;d:\audio.wav&quot;))</pre>
<hr>
<h2><a NAME="Syntax"></a>Syntax </h2>
<h4>Expressions:</h4> 
<p>An AviSynth script consists of multiple lines of statements looking like this: 
  &nbsp; 
<pre>variable_name = expression</pre>
<p>In this example expression is evaluated and the result is assigned to variable_name. 
<p>Very important is the common shortcut form: 
<pre>expression</pre>
<p>In this case, expression is evaluated and the result is assigned to the special 
  clip variable <var>last</var>. <br>
  This is the same as 
<pre>last = expression</pre>
<p>The end of the script often looks like: 
<pre>return expression</pre>
<p>Here expression is evaluated and is used as the "return value" of the script--that 
  is, the video clip that will be seen by the application which opens the AVS file. 
<p>If "return" is not specified explicitly, the clip <var>last</var> is used
  as a "return value".</p>
<p>The basic form of an expression which invokes a function is 
<pre>Function(args)</pre>
<p>Clip functions always produce a new video clip and never modify an existing 
  one, <br>
  Args is a list of function arguments separated by commas. The list can be empty 
  (which means all or some arguments can be optional) 
<p>If the filter function expects a video clip as its first argument, and that 
  argument is not supplied, then the clip in the special variable <var>last</var> 
  will be used. 
<p>AviSynth filters can take named arguments. The named arguments can be specified 
  in any order, <br>
  and the filter will choose default values for any that you leave off (named 
  arguments are always optional). <br>
  This makes certain filters much easier to use. 
<pre>You can write

Subtitle(&quot;Hello, World!&quot;, text_color=$00FF00, x=100, y=200)

instead of

Subtitle(&quot;Hello, World!&quot;, 100, 200, 0, 999999, &quot;Arial&quot;, 24, $00FF00)</pre>
<p>An alternate syntax (called "OOP notation") for clip functions is 
<pre>expression.Function(args)

e.g.:
Version.ReduceBy2.FadeOut(15)</pre>
<p>This is equivalent to 
<pre>Function(expression, args)

e.g.:
FadeOut(15, ReduceBy2(Version))</pre>
<p>and can be thought of <code>Function</code> applied to <code>expression</code>. <br>
  One disadvantage of OOP notation is that it can only be used with filters which 
  take a single video-clip argument, not with filters which take several. 
<p>All AviSynth functions produce defined number of output frames and framerate, 
  even if the statement seems very complex. <br>
  AviSynth knows after having read the script how long the output will be, which 
  framerate it has and the "cutting sequence" of all used inputs <br>
  This is all calculated on opening the script. Only the actual filtering is done 
  runtime on request. <br>
<hr>
<p><b>Comments</b>: AviSynth ignores anything from a # character to the end of 
  that line:
<pre># comment</pre>
<p>In
<em>v2.58</em> it is possible to add block and nested block comments in the
following way:
<pre># block comment:
/* 
comment 1
comment 2
*/</pre>
<pre># nested block comments:
[* [* a meaningful example with follow later :) *] *]</pre>

<p>AviSynth ignores anything from an <code>__END__</code> keyword (with double underscores) to the end of the script file. 
This can be used to disable some last commands of script.
</p>
<pre>Version()
__END__
ReduceBy2()
Result is not reduced and we can write any text here
</pre>
<p><b>Ignore Case</b>: aViSouRCe is just as good as AVISource. 
<p><b>Continue</b> on next or from previous line: \ 
 
<pre>Subtitle (&quot;Test-Text&quot;)

Subtitle ( \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Test-Text&quot;)

Subtitle (&nbsp;
       \ &quot;Test-Text&quot;)</pre>
<p> 
<hr>
<h4>Variables:</h4> 
<p>A variable name can be up to 50 characters long (actually more than 4000 characters in Avisynth
<em>v2.56</em>) and can contain (English) letters, digits, 
  and underscores (_), but no other characters. The name cannot start with a digit.
<p>You may use characters from your language system codepage (locale) 
  in strings and file names (ANSI 8 bit only, not Unicode).</p> 
<p>The following types of variables can be used: 
<p><var>clip</var>: a video clip containing video and / or audio. At least one 
  variable for a clip must be used and returned by the script. <br>
  <var>string</var>: surrounded either by "quotation marks" or by 3 quotation 
  marks like &quot;&quot;&quot;this example&quot;&quot;&quot;. A text string can 
  contain any character except the terminating quotation mark or double-apostrophe. 
  If you need to put a quotation mark inside a string, use the triple quote-notation:
<pre>Subtitle (&quot;&quot;&quot;This displays &quot;hello world&quot; with quotes&quot;&quot;&quot;)</pre>
<p><var>int:</var> entered as a string of digits, optionally with a + or - at 
  the beginning. <br>
  <var>float:</var> entered as a string of digits with a period (.) somewhere 
  in it and an optional + or -. For example, +1. is treated as a floating-point 
  number. <br>
  <var>val:</var> as type of a function argument where it does not matter if it 
  is int or float <br>
  <var>bool</var>: can be TRUE or FALSE <br>
  <var>hexadecimal numbers</var>: entered by preceding it with a $. This variable 
  is treated as an integer. Several filters use this notation for specifying colors. 
  For example, $FF8800 is a shade of orange. 
<p><var>global</var>: defines a global variable, which can be used by all user-defined 
  functions and the main script in common.
<p>Here's another version of the example from above that's more manageable and 
  easier to understand: 
<pre>a = AVISource(&quot;d:\capture.00.avi&quot;)
b = AVISource(&quot;d:\capture.01.avi&quot;)
c = AVISource(&quot;d:\capture.02.avi&quot;)
sound_track = WAVSource(&quot;d:\audio.wav&quot;)

AudioDub(a+b+c, sound_track)</pre>
<hr>
<h2> 
<a name="Colors"></a>Colors</h2>
<p> 
In some filters (BlankClip, Letterbox, AddBorders and FadeXXX) a color argument
can be specified. In all cases the color should be specified in RGB format even if
the color format of the input clip is YUV. This can be done in hexadecimal or
decimal notation. In hexadecimal notation the number is composed as follows:
the first two digits denote the red channel, the next two the green channel and
the last two the blue channel. The hexadecimal number must be preceded with
a&nbsp;$. In decimal notation the number is as follows: the red channel value
is multiplied by 65536, the green channel value is multiplied by 256 and the
two resulting products are both added to the blue channel value.
<p> 
Let's consider an example. Brown is given by R=$A5 (165), G=$2A (42), B=$2A (42).
Thus <code>BlankClip(color=$A52A2A)</code> gives a brown frame. Converting each channel to
decimal (remember that A=10, B=11, C=12, D=14, E=14, F=15) gives

<pre>R = $A5 = 10*16^1 +  5*16^0 = 165
G = $2A =  2*16^1 + 10*16^0 =  42
B = $2A =  2*16^1 + 10*16^0 =  42

165*65536 + 42*256 + 42 = 10824234</pre>
<p> 
Thus creating a brown frame specifying the color in decimal notation gives
<code>BlankClip(color=10824234)</code>.
<p>Common color presets can be found in the file <var>colors_rgb.avsi</var>, 
which should be present in your plugin autoload folder (look into the file for list of presets). 
Thus <code>BlankClip(color=color_brown)</code> gives the same brown frames.</p>
<p> 
Note that black RGB=$000000 will be converted to Y=16, U=V=128 if the
colorformat of the input clip is YUV, since the default color conversion RGB
[0,255] -&gt; YUV [16,235] is used. 
<hr>
<h2><a NAME="Operators"></a>Operators </h2>
<p>For all types of operands (clip, int, float, string, bool) you can use: <br>
  <code>==</code> is equal to<br>
  <code>!=</code> is not equal to
<p>For numeric types (int, float): <br>
  <code>+ </code>add <br>
  <code>- </code>subtract <br>
  <code>* </code>multiply <br>
  <code>/ </code>divide <br>
  <code>% </code>mod <br>
  <code>&gt;=</code> greater than or equal to <br>
  <code>&lt;=</code> less than or equal to <br>
  <code>&lt; </code>less than <br>
  <code>&gt; </code>greater than </p>
AviSynth in former versions parsed expressions from right to left, which gave
unexpected results: 
<pre>a = 10 - 5 - 5
resulted in 10 - (5 - 5) = 10
instead of (10 - 5) - 5 = 0 !</pre>
This bug has been corrected!
Starting from v2.53 also multiplication and division are parsed from left to
right (instead of right to left).
<p>For string type: <br>
  <code>+ </code>add <br>
  <code>&gt;=</code> greater or equal than (case-insensitive) <br>
  <code>&lt;=</code> less or equal than (case-insensitive) <br>
  <code>&lt; </code>less than (case-insensitive) <br>
  <code>&gt; </code>greater than (case-insensitive) 
<p>For clip type: <br>
  <code>+ </code>the same as the function <code>UnalignedSplice</code> <br>
  <code>++</code> the same as the function <code>AlignedSplice</code> 
<p>For bool type (true/false):<br>
<code>||</code> or <br>
  <code>&amp;&amp;</code> and <br>
  <code>?:</code> execute code conditionally 
<pre>b = (a==true) ? 1 : 2

This means in pseudo-basic:

if (a=true) then b=1 else b=2&nbsp;</pre>
<hr>
<h2><a NAME="ScriptFunctions"></a>Script Functions </h2>
<p>The input and output of these functions are not clips, but some other variables 
  used in the script. 
<h4>Numerical functions:</h4>
<table BORDER WIDTH="95%" >
  <tr> 
    <td WIDTH="62%"><code>Max(<var>int, int[, ...]</var>)</code> / <code>Max(<var>float, float[, ...]</var>)</code>:
	   Maximum value of a set of numbers.</td>
    <td WIDTH="40%"><code>Max</code> (1, 2) = 2<br>
      <code>Max</code> (5, 3.0, 2) = 5.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Min(<var>int, int[, ...]</var>)</code> / <code>Min(<var>float, float[, ...]</var>)</code>:
	   Minimum value of a set of numbers.</td>
    <td WIDTH="40%"><code>Min</code> (1, 2) = 1<br>
      <code>Min</code> (5, 3.0, 2) = 2.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>MulDiv(<var>int, int, int</var>)</code>: (m*n+d/2)/d
        using 64 bit intermediate result</td>
    <td WIDTH="40%"><code>MulDiv</code> (1, 1, 2) = 1<br>
      <code>MulDiv</code> (2, 3, 2) = 3</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Floor(<var>float</var>)</code>: converts from float to int</td>
    <td WIDTH="40%"><code>Floor</code> (1.2) = 1<br>
      <code>Floor</code> (1.6) = 1<br>
      <code>Floor</code> (-1.2) = -2<br>
      <code>Floor</code> (-1.6) = -2</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Ceil</code> (<var>float</var>): converts from float 
      to int</td>
    <td WIDTH="40%"><code>Ceil</code> (1.2) = 2.0<br>
      <code>Ceil</code> (1.6) = 2.0<br>
      <code>Ceil</code> (-1.2) = -1<br>
      <code>Ceil</code> (-1.6) = -1</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Round</code> (<var>float</var>): converts from float 
      to int</td>
    <td WIDTH="40%"><code>Round</code> (1.2) = 1<br>
      <code>Round</code> (1.6) = 2<br>
      <code>Round</code> (-1.2) = -1<br>
      <code>Round</code> (-1.6) = -2</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Int</code> (<var>float</var>): Converts from float
	to int (round towards zero).</td>
    <td WIDTH="40%"><code>Int</code> (1.2) = 1<br>
      <code>Int</code> (1.6) = 1<br>
      <code>Int</code> (-1.2) = -1<br>
      <code>Int</code> (-1.6) = -1</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Float</code> (<var>int</var>): Converts int to float.</td>
    <td WIDTH="40%"><code>Float</code> (1) = 1.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Frac</code> (<var>float</var>): Returns the fractional
	portion of the value provided.</td>
    <td WIDTH="40%"><code>Frac</code> (3.7) = 0.7<br>
      <code>Frac</code> (-1.8) = -0.8</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="4"><code>Abs</code> (<var>integer</var>) / <code>Abs</code> 
      (<var>float</var>): Returns the absolute value (returns float for float,
	  integer for integer).</td>
    <td WIDTH="40%" HEIGHT="4"><code>Abs</code> (-6) = 6<br>
                               <code>Abs</code> (-1.8) = 1.8</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sign</code> (<var>int</var>) / <code>Sign</code> (<var>float</var>):
      Returns sign of value (1, 0 or -1).</td>
    <td WIDTH="40%"><code>Sign</code>(-3.5) = -1<br>
      <code>Sign</code>(3.5) = 1<br>
      <code>Sign</code>(0) = 0</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="24"><code>HexValue</code> (<var>string</var>) Evaluates
	string as hexadecimal value.</td>
    <td WIDTH="40%" HEIGHT="24"><code>HexValue</code> ("FF00") = 65280</td>
  </tr>
  <tr> 
    <td COLSPAN="2"></td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sin</code> (<var>float</var>) Returns the sine of the
	argument (assumes it is radians).</td>
    <td WIDTH="40%">    Sin(Pi()/4) = 0.707&nbsp;<br>
    Sin(Pi()/2) = 1.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Cos</code> (<var>float</var>) Returns the cosine of the
	argument (assumes it is radians).</td>
    <td WIDTH="40%">    Cos(Pi()/4) = 0.707&nbsp;<br>
    Cos(Pi()/2) = 0.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Pi</code> () Returns the value of the "pi" constant
	(the ratio of a circle's perimeter to its diameter).</td>
    <td WIDTH="40%">d = Pi() # d == 3.141593</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Log</code> (<var>float</var>) Returns the natural
	(base-e) logarithm of the argument.</td>
    <td WIDTH="40%">    Log(1) = 0.0&nbsp;<br>
    Log(10) = 2.30259</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Exp</code> (<var>float</var>) Returns the natural
	(base-e) exponent of the argument.</td>
    <td WIDTH="40%">    Exp(1) = 2.718282&nbsp;<br>
    Exp(0) = 1.0</td>
  </tr>
  <tr> 
    <td WIDTH="62%" HEIGHT="24"><code>Pow</code> (<var>float base, float power</var>)
      Returns "base" raised to the power indicated by the second argument.</td>
    <td WIDTH="40%" HEIGHT="24">    Pow(2, 3) = 8&nbsp;<br>
    Pow(3, 2) = 9&nbsp;<br>
    Pow(3.45, 1.75) = 8.7334</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Sqrt</code> (<var>float</var>) Returns the square root of the argument.</td>
    <td WIDTH="40%">    Sqrt(1) = 1.0&nbsp;<br>
    Sqrt(2) = 1.4142</td>
  </tr>
  <tr> 
    <td COLSPAN="2"></td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Rand</code> (<var>[int max] [, bool scale] [, bool seed]</var>): 
      returns random integer between 0 and max.<br>
      &nbsp; defaults: max&nbsp;=&nbsp;32768, &nbsp;scale&nbsp;=&nbsp;TRUE,
                 &nbsp;seed&nbsp;=&nbsp;FALSE<br>
      &nbsp; Scale = FALSE, modulus mode, (Rand(32768)%limit)<br>
      &nbsp; Seed = TRUE, use time as seed</td>
    <td WIDTH="40%"><code>Rand</code>(100) = integer number between 0 and 99,
                    all number equally probable.<br>
                    <code>Rand</code>(32767, False) = integer number between 0 and 32766,
                    with 0 two times more probable than the other numbers.</td>
  </tr>
  <tr> 
    <td WIDTH="62%"><code>Spline</code> (<var>float X,&nbsp; x1,y1, x2,y2, ...., 
      bool "cubic"</var>}<strong> v2.5</strong> <br>
      &nbsp;Interpolates the Y value at point X using the control points x1/y1,... 
      <br>
      &nbsp;There have to be at least 2 x/y-pairs. <br>
      &nbsp;The interpolation can be cubic (the result is a spline) or linear 
      (the result is a polygon)</td>
    <td WIDTH="40%"><code>Spline</code> (5, 0,0, 10,10, 20,0, false) = 5<br>
      <code>Spline</code> (5, 0,0, 10,10, 20,0, true) = 7</td>
  </tr>
</table>
<h4>String functions:</h4>
<table BORDER WIDTH="95%" >
  <tr> 
    <td WIDTH="53%"><code>UCase</code> (<var>string</var>): returns the string 
      in uppercase</td>
    <td WIDTH="60%"><code>UCase</code> ("AviSynth") = "AVISYNTH"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>LCase</code> (<var>string</var>): returns the string 
      in lowercase</td>
    <td WIDTH="60%"><code>LCase</code> ("AviSynth") = "avisynth"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>RevStr</code> (<var>string</var>): returns the string 
      in reverse</td>
    <td WIDTH="60%"><code>RevStr</code> ("AviSynth") = "htnySivA"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>StrLen</code> (<var>string</var>): returns the length 
      of string</td>
    <td WIDTH="60%"><code>StrLen</code> ("AviSynth") = 8</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Findstr</code> (<var>string1, string2</var>):<br>
      returns the offset of string2 inside string1. The search is case-sensitive.</td>
    <td WIDTH="60%"><code>Findstr</code> ("AviSynth","syn") = 4</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>LeftStr</code> (<var>string, length</var>) / <code>RightStr</code> 
      (<var>string, length</var>):<br>
      returns left or right portion of string specified by length</td>
    <td WIDTH="60%"><code>LeftStr</code> ("AviSynth",3) = "Avi"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>MidStr</code> (<var>string, start [, length]</var>):<br>
      returns portion of string starting at start (for the first character start=1) 
      for the number of characters specified by length or to the end.</td>
    <td WIDTH="60%"><code>MidStr</code> ("AviSynth",3,2) = "iS"</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Chr</code> (<var>int</var>): returns the ASCII character 
      <strong>v2.5</strong></td>
    <td WIDTH="60%"><code>Chr</code> (34) returns the quote character</td>
  </tr>
  <tr> 
    <td WIDTH="53%"><code>Time</code> (<var>string</var>): returns a string with 
      the current system time formatted as defined by the string <strong>v2.5</strong><br>
    </td>
    <td WIDTH="60%">Codes for output formatting: <br>
      %a Abbreviated weekday name <br>
      %A Full weekday name <br>
      %b Abbreviated month name <br>
      %B Full month name <br>
      %c Date and time representation appropriate for locale <br>
      %d Day of month as decimal number (01 - 31) <br>
      %H Hour in 24-hour format (00 - 23) <br>
      %I Hour in 12-hour format (01 - 12) <br>
      %j Day of year as decimal number (001 - 366) <br>
      %m Month as decimal number (01 - 12) <br>
      %M Minute as decimal number (00 - 59) <br>
      %p Current locale's A.M./P.M. indicator for 12-hour clock <br>
      %S Second as decimal number (00 - 59) <br>
      %U Week of year as decimal number, with Sunday as first day of week (00 
      - 53) <br>
      %w Weekday as decimal number (0 - 6; Sunday is 0) <br>
      %W Week of year as decimal number, with Monday as first day of week (00 
      - 53) <br>
      %x Date representation for current locale <br>
      %X Time representation for current locale <br>
      %y Year without century, as decimal number (00 - 99) <br>
      %YYear with century, as decimal number <br>
      %z, %Z Time-zone name or abbreviation; no characters if time zone is unknown 
      <br>
      %% Percent sign 
      <p>The # flag may prefix any formatting code. In that case, the meaning 
        of the format code is changed as follows. 
      <p>%#a, %#A, %#b, %#B, %#p, %#X, %#z, %#Z, %#% # flag is ignored.&nbsp; 
        <br>
        %#c Long date and time representation, appropriate for current locale. 
        For example: "Tuesday, March 14, 1995, 12:41:29".<br>
        %#x Long date representation, appropriate to current locale. For example: 
        "Tuesday, March 14, 1995".&nbsp; <br>
        %#d, %#H, %#I, %#j, %#m, %#M, %#S, %#U, %#w, %#W, %#y, %#Y Remove leading 
        zeros (if any).
    </td>
  </tr>
</table>
<h4>Conversions:</h4>
<table BORDER WIDTH="95%" >
  <tr> 
    <td width="50%"><code>Value</code> (<var>string</var>): Returns the value 
      of an string.</td>
    <td WIDTH="50%"><code>Value</code> ( "-2.7" ) = -2.7</td>
  </tr>
  <tr> 
    <td width="50%"><code>String</code> (<var>float / int / string, format_string</var>):
      converts a number to a string.<br>
      <p>If the variable is float or integer, 
  it converts it to a float and uses the format_string to convert it to a string.</p>
      <p>The syntax of the format_string is as follows:</p>
      <p>%[flags][width][.precision]f<br>
  width: the minimum width (the string is never truncated)<br>
  precision: the number of digits printed<br>
  flags:<br>
  <tt>&nbsp;-&nbsp;&nbsp;&nbsp;</tt>left align (instead right align)<br>
  <tt>&nbsp;+&nbsp;&nbsp;&nbsp;</tt>always print the +/- sign<br>
  <tt>&nbsp;0&nbsp;&nbsp;&nbsp;</tt>padding with leading zeros<br>
  <tt>&nbsp;'&nbsp;'&nbsp;</tt>print a blank instead of a &quot;+&quot;<br>
  <tt>&nbsp;#&nbsp;&nbsp;&nbsp;</tt>always print the decimal point</p>
    </td>
    <td WIDTH="50%">e.g. <code>Subtitle</code> ("Clip height is " + <code>String</code> 
      (last.height) )<br>
      <br>
      <code>String</code>(1.23, &quot;%f&quot;) =      '1.23'<br>
      <code>String</code>(1.23, &quot;%5.1f&quot;) =   '  1.2'<br>
      <code>String</code>(1.23, &quot;%1.3f&quot;)  = '1.230'
    </td>
  </tr>
</table>
<h4>Version checking functions:</h4>
<table BORDER WIDTH="95%" >
  <tr> 
    <td WIDTH="50%"><code>VersionNumber</code> () <br>
    Returns AviSynth version number as float</td>
    <td WIDTH="50%"><code>VersionNumber</code> () = 2.56</td>
  </tr>
  <tr> 
    <td WIDTH="50%"><code>VersionString</code> () <br>
    Returns AviSynth version info as string (first line used in <code>Version</code> command).</td>
    <td WIDTH="50%"><code>VersionString</code> () = "AviSynth 2.56, build:Oct 28 2005 [18:43:54]" 
      </td>
  </tr>
</table>
<h4>Test functions:</h4> 
<p><code>IsBool(<var>var</var>) </code><br>
  <code>IsInt(<var>var</var>) </code><br>
  <code>IsFloat(<var>var</var>) </code><br>
  <code>IsString(<var>var</var>) </code><br>
  <code>IsClip(<var>var</var>) </code>
<h4>Other functions:</h4> 
<p><code>Select</code> (<var>index, item0 [, item1...]</var>): Returns item selected 
  by the index (0=item0). Items can be any variable or clip and can even be mixed.<br>
  <code>Defined</code> (<var>var</var>): for defining optional parameters in user-defined 
  functions. <br>
  <code>Default</code> (<var>x, d</var>): returns x if Defined(x), d otherwise. 
  <br>
  <code>Exist</code> (<var>filename</var>): returns TRUE or FALSE after checking 
  if the file exists.<br>
  <code>NOP</code> (): returns NULL, provided mainly for conditional execution 
  with non-return value items such as import and no "else" condition desired.<br>
  <code>Eval</code> (<var>string</var>),<br>
  <code>Apply</code> (<var>func-string, arg,...</var>): <code>Eval</code> ("f(x)") 
  is equivalent to <code>f(x)</code> is equivalent to <code>Apply</code> ("f", 
  x)
<pre>You can use Eval for something like:
settings = &quot;352, 288&quot;
Eval( &quot;BicubicResize(&quot; + settings + &quot;)&quot; )</pre>
<p><code>Import</code>(<var>filename</var>): evals contents of another AviSynth 
  script (imports the text of another script) 
<p>For error reporting and catching bad input to user-defined function you can 
  use: <br>
  <code>Assert</code>(<var>bool, string error-message</var>) 
<p><code>Try ... Catch</code>: this is a function for checking if an error WILL 
  arise:
<pre>Try {
&nbsp; AviSource(&quot;file.avi&quot;)
}
Catch(err_msg) {
&nbsp;&nbsp; Blackness.Subtitle(err_msg)
}</pre>
<hr>
<h2><a NAME="RuntimeFunctions"></a>Runtime Functions</h2>
<p>There are now <a href="corefilters/conditionalfilter.htm">Conditional 
  Filters</a> which evaluate scripts when a frame is processed, so you can change 
  variables on a per-frame basis. <br>
  To have more applications there have to be
  <a href="corefilters/conditionalfilter.htm#RuntimeFunctions">Runtime Functions</a>
  which evaluate the content of the clip and return a value. <strong>v2.5</strong> 
<p>
A simple example is to calculate the average luma for each frame and display it.

<pre>Version()      # Generate a test clip
ConvertToYV12()# We need YV12
FadeIn(10)     # Make the luma variable so
               # we can see something happen

               # Evaluate Subtitle(...) for each frame
               # the output of AverageLuma is converted to
               # a string and Subtitled on the input clip
ScriptClip(&quot; Subtitle(String(AverageLuma())) &quot;)
ConvertToRgb   # View it in RGB</pre>
<hr>
<h2><a NAME="ControlFunctions"></a>Control Functions </h2>
<p><code>SetMemoryMax</code> (<var>int</var>): Sets the maximum memory that AviSynth 
  uses (in MB). Setting to zero just returns the current Memory Max value.<strong> v2, (=0) v2.5.8</strong></p>

<p>In the 2.5 series the default Memory Max value is 25% the free physical
  memory, with a minimum of 16MB. From rev 2.5.8 RC4, 
  the default Memory Max is also limited to 512MB.</p>
<table>
  <tr> 
    <th>Free memory:</th>
    <td>&lt;64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>1024</td>
    <td>2048</td>
    <td>3072</td>
  </tr>
  <tr> 
    <th>Default Max v2.5.7 and older:</th>
    <td>16</td>
    <td>32</td>
    <td>64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>768</td>
  </tr>
  <tr> 
    <th>Default Max since v2.5.8 RC4:</th>
    <td>16</td>
    <td>32</td>
    <td>64</td>
    <td>128</td>
    <td>256</td>
    <td>512</td>
    <td>512</td>
  </tr>
</table>
<p>In some older versions there is a default setting of 5MB, which is quite low. If you 
  encounter problems (e.g. low speed) try to set this values to at least 32MB.
  Too high values can result in crashes because of 2GB address space limit.
  Return value: Actual MemoryMax value set.</p> 

<p><code>SetPlanarLegacyAlignment</code> (<var>clip, bool</var>): Set alignment mode for
  planar frames. <strong>v2.5.6</strong></p>

<p>Some older plugins illegally assume the layout of video frames in memory. This special
  filter forces the memory layout of planar frames to be compatible with prior version of
  AviSynth. The filter works on the GetFrame() call stack, so it effects filters
  <strong>before</strong> it in the script.</p>

<pre><strong>Example : Using an older version of Mpeg2Source()</strong>

LoadPlugin(&quot;...\Mpeg2Decode.dll&quot;)
Mpeg2Source(&quot;test.d2v&quot;)         # A plugin that illegally
                                # assumes the layout of memory
SetPlanarLegacyAlignment(true)  # Set legacy memory alignment
                                # for prior statements
ConvertToYUY2()                 # Statements thru to the end
                                # of the script have advanced
...                             # memory alignment.</pre>

<p><code>SetWorkingDir</code> (<var>string</var>): Sets the default directory 
  for Avisynth. <strong>v2</strong></p>

<p>This is primarily for easy loading of source clips, etc. Does not affect plugin 
  autoloading. Return value: 0 if successful, -1 otherwise.</p>

<p><code>global OPT_AllowFloatAudio=True</code>: <strong>v2.57</strong><br>
  This option enables WAVE_FORMAT_IEEE_FLOAT audio output.
  The default is to autoconvert Float audio to 16 bit.</p>

<p><code>global OPT_UseWaveExtensible=True</code>: <strong>v2.58</strong><br>
  This option enables WAVE_FORMAT_EXTENSIBLE audio output.
  The default is WAVE_FORMAT_EX.</p>

<p>Note: The default DirectShow component for .AVS files, "AVI/WAV File Source",
  does not correctly implement WAVE_FORMAT_EXTENSIBLE processing, so many
  application may not be able to detect the audio track. There are third
  party DirectShow readers that do work correctly. Intermediate work files
  written using the AVIFile interface for later DirectShow processing will
  work correctly if they use the DirectShow "File Source (async)" component
  or equivalent.

<hr>
<h2><a NAME="ClipProperties"></a>Clip Properties</h2>
<p>These functions take a clip as input and you get back a property of the clip.
<table border="1" width="100%">
  <tr>
    <td width="20%"><code>Width</code> (<var>clip</var>)</td>
    <td width="50%">Returns the width of the clip in pixels (type: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Height</code> (<var>clip</var>)</td>
    <td width="50%">Returns the height of the clip in pixels (type: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Framecount</code> (<var>clip</var>)</td>
    <td width="50%">Returns the number of frames of the clip (type: int).</td>
  </tr>
  <tr>
    <td width="20%"><code>Framerate</code> (<var>clip</var>)</td>
    <td width="50%">Returns the number of frames per seconds of the clip (type:
      float).</td>
  </tr>
  <tr>
    <td width="20%"><code>FramerateNumerator</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">&nbsp;</td>
  </tr>
  <tr>
    <td width="20%"><code>FramerateDenominator</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">&nbsp;</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiorate</code> (<var>clip</var>)</td>
    <td width="50%">Returns the sample rate of the audio of the clip.</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiolength</code> (<var>clip</var>)</td>
    <td width="50%">Returns the number of samples of the audio of the clip
      (type: int). Be aware of possible overflow on very long clips ( 2^31 samples limit).</td>
  </tr>
  <tr>
    <td width="20%"><code>AudiolengthF</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Returns the number of samples of the audio of the clip
      (type: float).</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiochannels</code> (<var>clip</var>)</td>
    <td width="50%">Returns the number of audio channels of the clip.</td>
  </tr>
  <tr>
    <td width="20%"><code>Audiobits</code> (<var>clip</var>)</td>
    <td width="50%">Returns the audio bit depth of the clip.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsAudioFloat</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Returns true if the bit depth of the audio of the clip is
      float.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsAudioInt</code> (<var>clip</var>) <strong>v2.55</strong></td>
    <td width="50%">Returns true if the bit depth of the audio of the clip an
      integer.</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB</code> (<var>clip</var>)</td>
    <td width="50%">Returns true if the clip is RGB, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB24</code> (<var>clip</var>)</td>
    <td width="50%">Returns true if the clip is RGB24, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsRGB32</code> (<var>clip</var>)</td>
    <td width="50%">Returns true if the clip is RGB32, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYUY2</code> (<var>clip</var>)</td>
    <td width="50%">Returns true if the clip is YUY2, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYV12</code> (<var>clip</var>) <strong>v2.51</strong></td>
    <td width="50%">Returns true if the clip is YV12, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsYUV</code> (<var>clip</var>) <strong>v2.54</strong> </td>
    <td width="50%">Returns true if the clip is YUV, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsPlanar</code> (<var>clip</var>) <strong>v2.51</strong> </td>
    <td width="50%">Returns true if the clip color format is planar, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsInterleaved</code> (<var>clip</var>) <strong>v2.51</strong> </td>
    <td width="50%">Returns true if the clip color format is interleaved, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>IsFieldBased</code> (<var>clip</var>)</td>
    <td width="50%">&nbsp;</td>
  </tr>
  <tr>
    <td width="20%"><code>IsFrameBased</code> (<var>clip</var>)</td>
    <td width="50%">&nbsp;</td>
  </tr>
  <tr>
    <td width="20%"><code>GetParity</code> (<var>clip, int "n"</var>)</td>
    <td width="50%">Returns true if frame n (default 0) is top field of fieldbased clip,
    or it is full frame with top field first of framebased clip (type: bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>HasAudio</code> (<var>clip</var>) <strong>v2.56</strong> </td>
    <td width="50%">Returns true if the clip has audio, false otherwise (type:
      bool).</td>
  </tr>
  <tr>
    <td width="20%"><code>HasVideo</code> (<var>clip</var>) <strong>v2.56</strong> </td>
    <td width="50%">Returns true if the clip has video, false otherwise (type:
      bool).</td>
  </tr>
</table>
<p>
Don't forget: you can use the Properties with the implicit variable LAST or in OOP-notation:
<pre>BilinearResize(Width/2, Height/2)
&nbsp;&nbsp; is the same as
BilinearResize(Width(Last)/2, Height(Last)/2)
&nbsp;&nbsp; is the same as
BilinearResize(Last.Width / 2, Last.Height / 2)</pre>
<p> 
<hr>
<h2><a NAME="userdefined"></a>User-Defined Functions </h2>
<p>You can define your own functions. This is best explained by an example: <br>
  &nbsp; 
<pre>Function NTSC2PAL( clip c) {
&nbsp;&nbsp;&nbsp; Assert(c.height == 480, \
           &quot;NTSC2PAL: input clip must have 480 scan lines&quot;)
&nbsp;&nbsp;&nbsp; Bob(c, height=576)
&nbsp;&nbsp;&nbsp; return Weave()
}</pre>
<p>Even recursive functions can be defined. <br>
  &nbsp; 
<pre>function TRANSITION(clip clip, int start, int expo, int overlap)
{
   return ( start &gt;= clip.framecount-expo ? 
\      Trim(clip,start,0) : 
\      Dissolve(Trim(clip,start,start+expo-1),
\         TRANSITION(clip,start+expo,expo,overlap),
\         overlap 
\              )
\         )
}</pre>
<p> 
<hr>
<h2><a NAME="multiclip"></a>Functions with more than one input clip </h2>
<p>There are some functions which combine two or more clips in different ways. 
  How the video content is calculated is described for each function, but here 
  is a summary which properties the result clip will have. 
<p>The input clips must always have the same color format and - with the exception 
  of <i>Layer</i> - the same dimensions.&nbsp; 
<table BORDER >
  <tr> 
    <td></td>
    <td> 
      <center>
        <b>frame-rate</b>
      </center>
    </td>
    <td COLSPAN="2"> 
      <center>
        <b>frame-count</b>
      </center>
    </td>
    <td> 
      <center>
        <b>audio content</b>
      </center>
    </td>
    <td> 
      <center>
        <b>audio sampling rate</b>
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>AlignedSplice, UnalignedSplice</b></td>
    <td ROWSPAN="6"> 
      <center>
        first clip
      </center>
    </td>
    <td> 
      <center>
        sum of all clips
      </center>
    </td>
    <td></td>
    <td> 
      <center>
        see filter description
      </center>
    </td>
    <td ROWSPAN="7"> 
      <center>
        first clip
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Dissolve</b></td>
    <td> 
      <center>
        sum of all clips minus the overlap
      </center>
    </td>
    <td></td>
    <td> 
      <center>
        see filter description
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Merge, MergeLuma, MergeChroma, Merge(A)RGB</b></td>
    <td ROWSPAN="2"> 
      <center>
        first clip
      </center>
    </td>
    <td ROWSPAN="5"> 
      <center>
        the last frame <br>
        of the shorter clip <br>
        is repeated until <br>
        the end of the clip
      </center>
    </td>
    <td ROWSPAN="5"> 
      <center>
        first clip
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>Layer</b></td>
  </tr>
  <tr> 
    <td><b>Subtract</b></td>
    <td ROWSPAN="2"> 
      <center>
        longer clip
      </center>
    </td>
  </tr>
  <tr> 
    <td><b>StackHorizontal, StackVertical</b></td>
  </tr>
  <tr> 
    <td><b>Interleave</b></td>
    <td> 
      <center>
        (fps of first clip) <br>
        x <br>
        (number of clips)
      </center>
    </td>
    <td> 
      <center>
        N x frame-count of longer clip
      </center>
    </td>
  </tr>
</table>
<p>As you can see the functions are not completely symmetric but take some attributes 
  from the FIRST clip. <br>
<hr>
<h2><a NAME="Plugins"></a>Plugins </h2>
<p>With these functions you can add external functions to AviSynth. 
<p><code>LoadPlugin</code> (<var>&quot;filename&quot; [, ...]</var>) 
<p>Loads one or more external avisynth plugins (DLLs). <br>
<hr>
<p><code>LoadVirtualDubPlugin</code> (<var>&quot;filename&quot;,
&quot;filtername&quot;, preroll</var>) 
<p>This loads a plugin written for VirtualDub. "filename" is the name of the .vdf 
  file. After calling this function, the filter will be known as "filtername" 
  in avisynth. VirtualDub filters only supports RGB32. If the video happens to 
  be in RGB24-format, then you must use <code>ConvertToRGB32</code> (<code>ConvertToRGB</code> 
  won't suffice). 
<p>Some filters output depends on previous frames; for those preroll should be 
  set to at least the number of frames the filter needs to pre-process to fill 
  its buffers and/or updates its internal variables. <br>
<hr>
<p><code>LoadVFAPIPlugin</code> (<var>&quot;filename&quot;,
&quot;filtername&quot;</var>)
<p>This allows you to use VFAPI plugins (TMPGEnc import plugins).<br>
<hr>

<p>
<code>LoadCPlugin</code> (<var>&quot;filename&quot; [, ...]</var>)<br>
<code>Load_Stdcall_Plugin</code> (<var>&quot;filename&quot; [, ...]</var>)</p>
<p>Loads so called Avisynth C-plugins (DLLs). <br>
Load_Stdcall_Plugin() is an alias for LoadCPlugin().&nbsp;
<br>C-plugins are created on pure C language and use special "AviSynth C API" 
(unlike ordinary Avisynt plugins which are created with MS C++). 
C-plugins must be loaded with LoadCPlugin() or Load_Stdcall_Plugin().
<p>
Kevin provides a LoadCPlugin.dll that overloads the LoadCPlugin() verb to support plugins compiled using the C subroutine calling sequence, use Load_Stdcall_Plugin() to load stdcall calling sequence plugins when using Kevins version.
Advice: keep these plugins outside your auto plugin loading directory to prevent
crashes. [<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=58840">discussion</a>]
[<a href="http://kevin.atkinson.dhs.org/avisynth_c/">AVISynth C API (by
kevina20723)</a>]</p>
<hr>
<h2><a NAME="autoloading"></a>Plugin autoload and name precedence <strong>v2</strong></h2>
<p>It is possible to put all plugins and script files with user-defined functions 
  or (global) variables in a directory from where all files with the extension 
  .AVSI (<strong>v2.08, v2.5</strong>, the type was .AVS in <strong>v2.05-2.07</strong>)
   and .DLL are loaded at startup, unloaded and then loaded dynamically as 
  the script needs them. 
<p>.AVSI scripts in this directory should only contain function definitions and global 
  variables, no main processing section (else strange errors may occur), it also 
  is not recommended to put other files in that directory. 
<p>The directory is stored in the registry (the registry key has changed for <strong>v2.5</strong>). 
  You can use double-clicking a .REG-file with the following lines to set the 
  path (of course inserting your actual path): <br>
  &nbsp; 
<pre>REGEDIT4


[HKEY_LOCAL_MACHINE\SOFTWARE\Avisynth]
&quot;plugindir2_5&quot;=&quot;c:\\program files\\avisynth 2.5\\plugins&quot;</pre>
<p>The order in which function names take precedence is as follows: 
<pre>user-defined function (always have the highest priority)
   plugin-function (have higher priority than built-in
   functions, they will override a built-in function)
      built-in function</pre>
<p>Inside those groups the function loaded at last takes precedence, there is 
  no error in a namespace conflict. </p>
<h2><a NAME="autoloading_confl"></a>Plugin autoload and conflicting function
names <strong>v2.55</strong> </h2>
<p>Starting from v2.55 there is DLLName_function() support. The problem is that
two plugins can have different functions which are named the same. To call the
needed one, DLLName_function() support is added. It 
auto-generates the additional names both for auto-loaded plugins and for plugins loaded with
LoadPlugin. </p>
<p><b>Some examples:</b> </p>
<pre># using fielddeinterlace from decomb510.dll
AviSource(&quot;D:\captures\jewel.avi&quot;)
decomb510_fielddeinterlace(blend=false)</pre>
<p>Suppose you have&nbsp; the plugins mpeg2dec.dll and mpeg2dec3.dll in your
auto plugin dir, and you want to load a d2v file with mpeg2dec.dll (which
outputs YUY2): </p>
<pre># using mpeg2source from mpeg2dec.dll
mpeg2dec_mpeg2source(&quot;F:\From_hell\from_hell.d2v&quot;)</pre>
<p>or with mpeg2dec3.dll (which outputs YV12): </p>
<pre># using mpeg2source from mpeg2dec3.dll
mpeg2dec3_mpeg2source(&quot;F:\From_hell\from_hell.d2v&quot;)</pre>
<p><kbd>$Date: 2008/12/06 16:37:26 $</kbd></p>
</body>
</html>
