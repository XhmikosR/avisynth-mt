<html><head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>MaskTools</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: masktools.htm,v 1.2 2006/12/13 21:01:40 fizick Exp $ 
-->
</head>
<body>
<h1>MaskTools</h1>
<h2>Общая информация</h2>
<b>Авторы:</b>  kurosu и Manao
<br><b>Версия:</b>    1.5.8
<br><b>Где взять:</b>  <a href="http://manao4.free.fr/">http://manao4.free.fr/</a><br>
<b>Категория:</b>  Разное<br>
<b>Требования:</b> Цветовое пространство YV12
<hr>
<h2>Содержание 
</h2>
<ul>
  <li><a href="#masktools">
I) О MaskTools</a>
    <ul>
      <li><a href="#simple">1) Общее описание</a></li>
      <li><a href="#description">2) Детальное описание</a></li>
    </ul>
  </li>
  <li><a href="#functions">II) Описания функций</a></li>
  <li><a href="#examples">III) Практическое использование</a>
    <ul>
      <li><a href="#msharpen">1) MSharpen</a></li>
      <li><a href="#msoften">2) MSoften</a></li>
      <li><a href="#rainbow">3) Устранение "радуги"</a></li>
      <li><a href="#fxtoon">4) Передискретизация в fxtoon</a></li>
      <li><a href="#warpsharp">5) Warpsharp для темных клипов</a></li>
      <li><a href="#deinterlacer">6) псевдо - деинтерлейс (проблемы с цветностью 
все равно останутся)</a></li>
      <li><a href="#rect_overlay">7) Непрямоугольные наложения</a></li>
      <li><a href="#backgournd">8) Замена фона</a></li>
      <li><a href="#mftoon">9) Kmf-Toon ;-)</a></li>
    </ul>
  </li>
  <li><a href="#todo">IV) Планы на будущее</a></li>
  <li><a href="#disclaimer">V) Предупреждение (не пропустите эту часть, но я не заставляю Вас
изучать ее)</a></li>
  <li><a href="#revisions">VI) Версии</a></li>
  <li><a href="#developer">VII) Обзор для разработчиков</a></li>
</ul>
<h2><a name="masktools"></a>I) О MaskTools
</h2>
<h3><a name="simple"></a>1) Общее описание
</h3>
<p>После обработки клипа обычно нужна только часть результата. Например,
у вас есть клип, который назван smooth и является результатом сглаживания
(размытия, например фильтром blur() ) клипа, который назовем source.<br>
Большую часть шума удалось убрать, но также исчезли и детали. Таким образом
хорошо было бы сохранить часть пикселей из исходного клипа там, где есть
большая разница в цвете или яркости. Так работает фильтр MSmooth, от D. 
Graft. Теперь предположим, что мы заменим все те пикселы из сглаженного
варианта клипа, которые хотелось бы оставить, на белые, а остальные - на
черные. Это и есть так называемая маска. Набор фильтров MaskTools предназначен
для создания, преобразования и использования таких масок в цветовом пространстве
YV12 </p>
<h3><a name="description"></a>2) Описание
</h3>
<p>В этом плагине имеются следующие функции :
</p>
<ul>
  <li><a href="#binarize">Binarize</a> Превращает клип в маску на основании
порогового преобразования
</li>
  <li><a href="#combmask">CombMask</a>
Производит маску, содержащую информацию о тех местах исходного клипа, где
наблюдается "гребенка" 
</li>
 <li><a href="#dedgemask">DEdgeMask / DEdgeMask2</a> 
Строит маску, содержащую только те места исходного клипа, где есть резкие
перепады контраста (края деталей изображения), с использованием  
порогов для сравнения. Пороги можно отменить, задавая соответствующие значения параметров.
</li>  
  <li><a href="#edgemask">EdgeMask</a>
Строит маску, содержащую только те места исходного клипа, где есть резкие
перепады контраста, используя указанную величину порогов для сравнения. Пороги
можно отменить, задавая соответствующие значения параметров. То же, что и
DEdgeMask, но с предопределенным ядром преобразования.
</li>
<li><a href="#expand">Expand</a> "расширяет" области с максимальными значениями
пикселов, распространяя значение максимума из области 3х3 пиксела
на всю эту область.
Обратная функция называется <a href="#expand">Inpand</a>.</li>

<li><a href="#fitplane">FitY2UV/FitY2U/FitY2V</a> 
Изменяет размер плоскости Y и заменяет какую-то из плоскостей
UV/U/V тем, что получилось в результате изменения размера.
Можно задавать любую функцию масштабирования, втч. и не встроенную
в АвиСинт.
Обратные функции называются FitU2Y и FitV2Y.</li>

  <li><a href="#expand">Inflate</a> будет 'раздувать' пикселы с наибольшими
значениями, заменяя каждый пиксел на среднее арифметическое 8ми соседних
пикселов если оно окажется больше исходного значения этого пиксела.
Обратное действие производит функция <a href="#expand"> Deflate</a>
(посвящается Phil Katz) <i>(Фил Кац - изобретатель программы PKZip - прим. перев)</i></li>

  <li><a href="#invert">Invert</a>
производит инверсию пиксела (т.е. out = 255 - in); может также служить
для производства эффекта "соляризации" картинки.</li>

  <li><a href="#logic">Logic</a> 
производит основные логические операции (на самом деле те, которые есть 
в наборе команд MMX, хотя функции C тоже имеются, в основном из-за 
ограничений, связанных с размерами картинки).
</li>

  <li><a href="#LUT">RGBLUT/YV12LUT/YV12LUTxy</a>
представляют собой просто табличные преобразования и позволяют быстро
применить функцию к каждому пикселу изображения.
</li>

  <li><a href="#maskedmerge">MaskedMerge</a>
берет 3 клипа и производит объединение первого и второго,  взвешенное по маске,
которую представляет третий клип.
</li>

  <li><a href="#motionmask">MotionMask</a>
создает маску по движению в кадре.
</li>

  <li>OverlayMask 
сравнивает 2 клипа по их яркости и цветности и создает маску на основании
схожести этих значений с использованием порогов сравнения (почти то же
самое что делает ColorKeyMask).</li>
  <li><a href="#convolution">YV12Convolution</a>
позволяет производить свертку картинку по произвольной матрице.
</li>
  <li>YV12Layer - эквивалент OverLay.</li>
  <li><a href="#subtract">YV12Substract</a>-
то же, что и Subtract, работает в YV12, но *должна* быть немного побыстрее
(т.к. использует MMX).</li>
</ul>
<p>В дополнение к вышесказанному, все функции кроме группы FitPlane,
допускают еще 3 параметра: Y, U и V. В зависимости от значений этих
параметров к соответствующим цветовым плоскостям применяются следующие
операции :
</p>
<ul>
  <li>значение = 3 означает что к указанной плоскости будет
применено соответствующее преобразование,</li>
  <li>значение = 2 означает что в указанную плоскость будет помещена
копия 2й цветовой плоскости (если это возможно)</li>
  <li>значение = 1 означает что указанная плоскость вообще не будет
никак обрабатываться.</li>
  <li>значение = [-255...0] приведет к заполнению плоскости указанным
значением, взятым с обратным знаком (например, чтобы получить яркость
без цветовой информации, поставьте U=128,V=128)</li>
</ul>
<p>И наконец, некоторые функции могут обрабатывать только часть кадра:</p>
<ul>
  <li>эта возможность определяется параметрами (offX, offY) (положение 
начальной точки) и (w,h) (ширина и высота обрабатывамой области); 
фильтры должны модифицировать эти параметры так, чтобы обрабатываемая
область находилась внутри обеих картинок.</li>
  <li>если фильтр использует 2 клипа (исключение - YV12Layer),
то оба клипа должны иметь одинаковые размеры</li>
  <li>во всех случаях, размеры картинки должны быть как минимум кратны 8
(а иногда 16) чтобы фильтры могли использовать MMX и работать на полной 
скорости.</li>
</ul>
<p>Первоначально все это задумывалось имея в виду модульность и атомарность
операций (или полезность), а вовсе не скорость. В результате получилось все
раздутым и медленным. Сами решайте, действительно это так, или не совсем...
Примеры из III) со встроенными фильтрами должны работать быстрее.<br>
</p>
<h2><a name="functions"></a>II) Описания функций.
</h2>
<h3><a name="binarize"></a>Binarize
</h3>
<p><code>Binarize</code> (<var>clip, int "threshold", bool
"upper"</var>)<br>
<br>
The <code> Binarize</code> производит пороговое преобразование.
Если <var>upper</var>=true, то пиксел, значение которого строго больше
порога, будет установлен в 0, в противном случае - в 255.
Напротив, при <var>upper</var>=false, то пиксел, значение которого 
строго больше чем параметр <var>threshold</var>, будет установлен в 
255, в противном случае - в 0.
<br>
<br>
Значения по умолчанию такие : <var>threshold </var>= 20,
<var>upper </var>= true.
</p>
<h3><a name="combmask"></a>CombMask
</h3>
<p><code>CombMask</code> (<var>clip, int "thY1", int 
"thY2"</var>)
</p>
<p>
Этот фильтр строит маску, содержащую те места исходного клипа, где
наблюдается "гребенка". Значения порогов работают так же, как и в других
фильтрах : после вычисления оценки "гребенчатости", если это значение
меньше <var>thY1</var>, то пикселу присваивается 0, если больше 
<var>thY2</var>, пикселу присваивается 255, если посередине, то
значение оценки делится на 256 и присваивается пикселу.
</p>
<p>Оценка гребенки это (upper_pixel - pixel)*(lower_pixel - pixel).
Как можно видеть, результат не приводится к диапазону 0..255, (не нормализуется),
поскольку если бы это делалось, обычное значение было бы 1 или 2, не более.
Таким образом можно устанавливать пороги выше чем 255, хотя это вряд ли полезно.
</p>
<p>Значения по умолчанию : <var>thY1</var> = 10 и <var>thY2</var> = 10 
( таким образом по умолчанию получается маска с двумя возможными значениями пикселей ).
</p>
<h3><a name="dedgemask"></a>DEdgeMask / DEdgeMask2
</h3>
<p><code>DEdgeMask</code> (<var>clip, int "thY1", int
"thY2", int "thC1", int "thC2", string
"matrix", float "divisor", bool "setdivisor", bool "vmode"</var>)<br>
<code>DEdgeMask2</code> (<var>clip source, clip low_thres, 
clip high_thres, string"matrix", float "divisor", bool "setdivisor", 
bool "vmode"</var>)<br>
<br>
Этот фильтр делает маску краев деталей изображения (или просто краев) - 
областей с максимальными перепадами контраста. Алгоритм использует
свертку, результат которой сравнивается с порогами <var> thY1</var> и
<var> thY2</var> ( яркость );  <var> thC1</var> и <var> 
thC2</var> ( цветность ). Сравнение по порогам производится следующим образом
( r  -  результат свертки ) :

</p>
<ul>
  <li>r &lt;= th1 дает 0.</li>
  <li>th1 &lt; r &lt;= th2 дает r.</li>
  <li>th2 &lt; r дает 255.</li>
</ul>
<p>Чтобы получилась маска с двумя уровнями, нужно установить th1=th2.</p>
<p>Выбор ядра свертки осуществляется при помощи параметра <var>matrix</var>.
Ее значение должно быть матрицей 3 на 3 с целочисленными коэффициентами,
разделенными одиночными пробелами.
Так, строки "-1 -1 -1 -1 8 -1 -1 -1 -1" и "0 -1 0 -1 0 1 0 1 0" 
дадут операторы Лапласа и Собеля соответственно 
(см. "laplace" и "sobel" в описании к <a href="#edgemask">EdgeMask</a>.</p>
<p>Так как коэффициенты должны быть целыми, параметр <var> divisor</var> 
служит для уточнения результата свертки. Этот результат будет поделен на
значение параметра <var>divisor</var>. 
Если  <var> divisor</var> не определен, то по умолчанию он берется равным
сумме положительных коэффициентов матрицы, то есть производит нормализацию
результата. Этот параметр может быть как целым числом, так и числом с плавающей
точкой, хотя с целым числом фильтр будет работать быстрее.<br>
Параметр <var>setdivisor </var> нужен только для совместимости с предыдущими
версиями. Не надо его использовать.<br>
Наконец, <var>vmode</var> позволяет сделать маску с центральным значением 
128, а не 0.
Значения по умолчанию : <var>thY1 </var>= 0, <var>thY2 </var>= 20, <var>thC1 </var>= 0, 
<var>thC2
</var>= 20, <var>matrix </var>= "-1 -1 -1 -1 8 -1 -1 -1 -1" и <var>vmode</var>=false.</p>
<p>DEdgemask2 работает в целом так же как и DEdgeMask, за исключением того,
что вместо двух числовых значений порогов он требует задания двух клипов.
Каждый из этих клипов содержит локальные пороги для каждого пикселя.
Например, нужно сделать адаптивные пороги в зависимости от контраста
каждого кадра. Локальные минимумы и максимумы можно сделать посредством
inpand() and expand(). Разность делается с помощью YV12LUTxy или YV12Subtract.
И вот пожалуйста, получаем клип с пороговыми значениями, зависящими от
локального контраста.</p>

<h3><a name="edgemask"></a>EdgeMask</h3>
<p><code>EdgeMask</code> (<var>clip, int "thY1", int 
"thY2", int
"thC1", int "thC2", string "type"</var>)<br>
<br>
Этот фильтр создает маску краев изображения. Алгоритм поиска краев использует
свертку, результат которой сравнивается с порогами <var> thY1</var> и
<var> thY2</var> ( яркость );  <var> thC1</var> и <var> 
thC2</var> ( цветность ). Сравнение по порогам производится следующим образом
( r  -  результат свертки ) :
</p>
<ul>
  <li> r &lt;= th1 дает 0.</li>
  <li> th1 &lt; r &lt;= th2 дает r.</li>
  <li> th2 &lt; r дает 255.</li>
</ul>
<p>Чтобы получилась маска с двумя уровнями, нужно установить th1=th2.</p>
<p>Выбор ядра свертки производится заданием параметра <var> type</var> :</p>
<ul>
  <li><var> type</var> = "roberts" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%">2</td>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "sobel" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">-1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "laplace" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/8</td>
      </tr>
    </tbody></table>
  </li>
  <li><var> type</var> = "special" :<br>
    <table border="1" width="15%">
      <tbody><tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%">1</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
      </tr>
      <tr>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
        <td align="center" height="5%" valign="middle" width="25%">0</td>
        <td align="center" height="5%" valign="middle" width="25%"> -1/4</td>
      </tr>
    </tbody></table>
  </li>
</ul>
<p>Возможны еще два значения параметра <var> type</var> ("cartoon" и "line" ),
которые не документированы.</p>
<p>Значения по умолчанию : <var>thY1 </var>= 0, <var>thY2 </var>= 20, <var>thC1 </var>=
0, <var>thC2 </var>= 20 and <var>type </var>= "sobel".</p>
<h3><a name="fitplane"></a>FitY2U / FitY2V / FitY2UV  FitU2Y / FitV2Y /
FitU2V / FitV2U</h3>
<p>Фильтры <code>FitPlane</code> (<var>clip, string resizer</var>) </p>
<p>Семейство фильтров <code>FitPlane</code> включает следующие фильтры :<br>
   - яркость в цветность: <code>FitY2U</code>, <code>FitY2V</code>, <code> 
FitY2UV</code><br>
   - цветность в яркость: <code>FitU2Y</code>, <code> FitV2Y</code><br>
   - цветность в цветность: <code>FitU2V</code>, <code> FitV2U</code></p>
<p>При помощи этих фильтров маску, созданную для одной цветовой плоскости 
можно распространить на другую цветовую плоскость.</p>
<h3><a name="expand"></a>Inpand / Expand / Deflate / Inflate
</h3>
<p><code>Inpand</code> (<var>clip</var>)<br>
<code>Expand</code> (<var>clip</var>)<br>
<code>Deflate</code> (<var>clip</var>)<br>
<code>Inflate</code> (<var>clip</var>)
</p>
<p>Эти фильтры позволяют увеличить или уменьшить маску.
<code>Expand</code> заменяет значение пиксела максимумом из значений
всех окружающих пикселов. <code>Inpand</code> наоборот, выбирает минимальное
значение.
<code>Inflate</code> вычисляет среднее значение окружающих пикселов, и
заменяет данный пиксел вычисленным средним только если это среднее больше
исходного значения пиксела.
<code>Deflate</code> делает то же самое, но заменяет пиксел если среднее
значение окружающих пикселов меньше исходного значения пиксела.</p>
<p>Изображения, полученные в результате действия фильтров
<code>Expand</code> и <code>Inflate</code> будут иметь более высокие значения
пикселов, чем исходные.
Напротив, в результате действия <code>Inpand</code> и <code>Deflate</code>
получатся изображения с более низкими значениями пикселов.
</p>
<p>Увеличение (уменьшение) маски, произведенное <code>Deflate</code> 
(<code>Inflate</code>) выглядит более мягким, чем произведенное
<code>Expand</code> (<code>Inpand</code>).
</p>
<h3><a name="hysteresymask"></a>HysteresyMask
</h3>
<p><code>HysteresyMask</code> (<var>mask_clip1, mask_clip2</var>)
</p>
<p>Этот фильтр делает одну маску из двух. Теоретически первая должна
лежать внутри второй, хотя все будет работать и если это не так. Однако
результаты будут менее интересными. Идея этого фильтра состоит в том,
чтобы усилить те части маски, которые принадлежат обеим маскам.
</p>
<p>Этот алгоритм интересен тем, что позволяет, например, взять одну маску,
содержащую все края всех деталей изображения, плюс, естественно, шум,
и вторую, с минимумом деталей и минимумом шума,  и получить результат,
содержащий наиболее интересные края деталей изображения, но без шума 
(которого не было во второй маске).</p>
<h3><a name="invert"></a>Invert
</h3>
<p><code>Invert</code> (<var>clip, int offX, int offX, int w, int h</var>)
</p>
<p>Этот фильтр заменяет значение пиксела на 255 - (значение пиксела).
</p>
<p>Binarize(upper=false) можно рассматривать как 
</p>
<p>Invert().Binarize(upper=true)
</p>
<p>(хотя оно в действительности обрабатывается совсем не так).
</p>
<h3><a name="logic"></a>Logic
</h3>
<p><code>Logic</code> (<var>mask_clip1, mask_clip2, string 
"mode"</var>)
</p>
<p>Этот фильтр создает маску, являющуюся результатом операции с двумя 
масками. Тип операции задается параметром <var>mode</var>.
</p>
<ul>
  <li><var>mode</var>="and" : работает только с двухуровневыми масками
(пикселы которых имеют значения только 0 или 255 ). На выходе получается 
пересечение двух масок, т.е. если оба исходных пиксела имеют значение 255,
то результат будет 255, в противном случае 0.</li>
  <li><var>mode</var>="or" : работает только с двухуровневыми масками
На выходе получается 
объединение двух масок, т.е. если хотя бы один исходный пиксел имеет
значение 255, то результат будет 255, в противном случае 0.</li>
  <li><var>mode</var>="xor" : работает только с двухуровневыми масками
На выходе получается 
разность двух масок, т.е. если один исходный пиксел имеет
значение 255 а второй 0, то результат будет 255, в противном случае 0.
</li>
  <li><var>mode</var>="andn" : работает только с двухуровневыми масками
На выходе получается разность между первой и второй масками, т.е. если 
исходный пиксел первой маски имеет значение 255 а второй маски - 0, 
то результат будет 255, во всех остальных случаях 0.
</li>
  <li><var>mode</var>="min" : возвращает минимум значений соответствующих
пикселов первой и второй масок. Для двухуровневых масок это то же самое 
что <var>mode</var>="and".</li>
  <li><var>mode</var>="max" : возвращает максимум значений соответствующих
пикселов первой и второй масок. Для двухуровневых масок это то же самое 
что <var>mode</var>="or".</li>
</ul>
<p>Результат логической операции, произведенной над пикселами, значения которых
отличаются от 0 и 255 непредсказуем.
</p>
<p>Значение по умолчанию : <var>mode </var>= "and".
</p>
<h3><a name="LUT"></a>RGBLUT / YV12LUT / YV12LUTxy / YUY2LUT</h3>
<p><code>YV12LUT</code> (<var>clip, string "yexpr", string
"uexpr", string "vexpr"</var>)<br>
<code>YUY2LUT</code> (<var>clip, string "yexpr", string"uexpr", string "vexpr"</var>)<br>
<code>RGBLUT</code> (<var>clip, string "Rexpr", string
"Gexpr", string "Bexpr", string "AMPFile"</var>)<br>
<code>YV12LUTxy</code> (<var>clipx, clipy, string "yexpr", string
"uexpr", string "vexpr"</var>)
</p>
<p>Эти фильтры вычисляют заданную функцию для каждого пиксела изображения.
Для того чтобы повысить скорость фильтра, все возможные результаты функции
вычисляются заранее и хранятся в таблице.
<code>RGBLUT</code>  работает так же как и <code>YV12LUT</code>, за исключением
дополнительного параметра <var>AMPFile</var>. Он позволяет подгрузить
цветовой профиль фотошопа (color profile в англоязычной версии).
</p>
<p>
Функция задается в в виде строки с выражением в так называемой 
<i>обратной польской записи</i>. Идея состоит в том чтобы писать сначала
аргументы а потом оператор, действующий на эти аргументы. Так, вместо "3 + 7" 
надо писать "3 7 +", а "sin(3)" становится "3 sin". Далее, 
"3 * 7 + 5" переходит в "3 7 * 5 +", а "(3 + 7) * 5" в "3 7 + 5 *". 
Это похоже на советские программируемые калькуляторы Б3-34 и подобные (прим. перев.)
Главное достоинство такой записи - полное отсутствие скобок.
</p>
<p>
Вычисления производятся над вещественными числами. Положительные значения
в логических выражениях означают "истина", отрицательные - "ложь".
Символ "x" означает исходное значение пиксела. В функции <code>YV12LUTxy</code>
используется также обозначение "y" для соответствующего пиксела из второго
клипа. Элементы выражения (числа, символы и  знаки операций) должны быть
разделены одиночными пробелами.
</p>
<p>Вот некоторые функции и операторы :
</p>
<ul>
  <li>+, -, /, *, ^, % - соответственно сложение, вычитание, деление, умножение,
возведение в степень и остаток от деления.</li>
  <li>&amp;, |, °, !&amp; - логические операции "и", "или", "исключающее или", "не".
В качестве логического значения "истина" они возвращают 1.0, "ложь" представляется 
как -1.0.</li>
  <li>&lt;, &lt;=, &gt;, &gt;=, =, != - операции сравнения "меньше", "меньше или равно",
"больше", "больше или равно", "равно", "не равно". В случае если условие истинно,
они возвращают 1.0, иначе как -1.0.
</li>
  <li>cos, sin, tan, acos, asin, atan, exp, log, abs - это функции косинус,синус,
тангенс, арккосинус, арксинус, арктангенс, е<sup>x</sup> логарифм и модуль.
</li>
  <li>? означает условное выражение. Это тернарный оператор ( с тремя аргументами)
Первый из них - условие, второй - значение если условие истинно, третий - если ложно.
</li>
</ul>
<p>Примеры :
</p>
<p>* Постеризация картинки по порогу в 128 : "x 128 &lt; 0 255 ?".
Это переводится на язык С как : "(x &lt; 128) ? 0 : 255".<br>
   * Levels(il, gamma, ih, ol, oh) ( см. фильтр <a href="../corefilters/levels.htm"> Levels</a> ) : "x il - ih il - / 1 gamma / ^ 
oh
ol - *".
На С это будет "(((x - il) / (ih - il)) ^ (1 / gamma)) * (oh - ol)".
</p>
<p>Значение по умолчанию : <var>Yexpr</var> = <var>Uexpr</var> = <var>Vexpr</var> =
"x" ( то есть попросту ничего не делать ).
</p>
<h3><a name="maskedmerge"></a>MaskedMerge
</h3>
<p><code>MaskedMerge</code> (<var>base_clip, overlay_clip, mask_clip</var>)
</p>
<p>Этот фильтр накладывает клип, заданный как <var>overlay_clip</var> на клип 
<var>base_clip</var> по маске <var>mask_clip</var>.
А именно, пусть <i>bc</i>, <i> oc</i> и <i> mc</i> представляют
значения трех соответствующих пикселов в 
<var>base_clip</var>, <var>overlay_clip</var> и <var>mask_clip</var>, 
тогда результат будет такой :
</p>
<pre>v = ((256 - <i>mc</i>) * <i>bc</i> + <i>mc</i> * <i>oc</i> + 128) / 256
</pre>
<p>128 присутствует здесь чтобы уменьшить ошибку, возникающую из-за целочисленного
деления.
</p>
<p>Таким образом, там где маска равна  255, результат будет взят из
<var>overlay_clip</var>, где маска равна 0, результат будет взят из
<var>base_clip</var>, а при промежуточных значениях маски будет одним из
переходных от <var>overlay_clip</var> к <var>base_clip</var> значений.
</p>
<h3><a name="motionmask"></a>MotionMask
</h3>
<p><code>MotionMask</code> (<var>clip, int "thY1", int "thY2", 
int "thC1", int "thC2", int "thSD"</var>)
</p>
<p>Этот фильтр создает маску движения картинки. Как и в других фильтрах,
после создания маска подвергается пороговому преобразованию. Этот фильтр
также проверяет наличие смены сцены и не выдает маску если такая смена 
имеет место.
</p>
<p>Определение смены сцены осуществляется посредством вычисления суммы
отличий данного кадра и предыдущего. Эта сумма нормируется (averaged ?)
и сравнивается с порогом <var>thSD</var>. Если она оказывается больше
этого порога, то фиксируется факт смены сцены. 
</p>
<p>Движение анализируется подобно <a href="nomosmooth.htm">NoMoSmooth</a>, 
то есть для каждого пиксела вычисляется сумма отличий данного пиксела и
всех окружающих от соответствующих пикселов предыдущего кадра. Полученная
сумма делится на 9 чтобы результат лежал между  0 и 255.
</p>
<p>Этот алгоритм дает некую оценку движения. Он хорошо работает на краях
изображения, и хуже - на однородных участках. 
</p>
<p>Значения по умолчанию : <var>thY1</var>= 20, <var>thY2</var> = 20, <var>thC1</var> =
10, <var>thC2</var> = 10 и <var>thSD</var> = 10.
</p>
<h3><a name="convolution"></a>YV12Convolution
</h3>
<p><code>YV12Convolution</code> (<var>clip, string "horizontal", 
string "vertical", int "total", bool "automatic", bool "saturate"</var>)
</p>
<p>
Эти фильтры вычисляют свертку картинки с ядром, образованным произведением
строки <var>horizontal</var> на столбец <var>vertical</var>. Обе эти параметра
должны содержать нечетное количество целых или вещественных чисел, разделенных
одиночными пробелами.
Параметр <var>total</var> - фактор нормализации, на который делится произведение
вышеописанных векторов.
Если параметр <var> automatic</var> равен 'true', то результат делится на сумму
коэффициентов матрицы. Таким образом, общая яркость картинки не изменяется.
<var>Saturate</var> позволяет определить поведение фильтра в случае если результат
свертки меньше нуля.
</p>
<ul>
  <li><var>saturate</var> = true : отрицательные значения заменяются на нули.</li>
  <li><var>saturate</var> = false : отрицательные значения берутся по модулю.</li>
</ul>
<p>Если параметр <var>total</var> не задан, он полагается равным сумме 
коэффициентов ядра свертки, таким образом достигается хорошая нормализация
для сверток типа размытие / повышение резкости.
</p>
<p>
Если хотя бы один коэффициент горизонтального или вертикального векторов
представлен вещественным числом, то все вычисления будут производиться с
вещественными числами, в результате фильтр будет работать медленнее.
</p>
<p>Значения по умолчанию : <var>horizontal</var> = "1 1 1", <var>vertical</var> = 
"1 1 1",
<var>automatic</var> = false, <var>saturate</var> = true.
</p>
<h3><a name="subtract"></a>YV12Subtract
</h3>
<p><code>YV12Subtract</code> (<var>clip1, clip2, int tol, bool
"widerange"</var>)
</p>
<p>
Этот фильтр вычисляет разность между двумя клипами. Существует несколько 
способов вычисления такой разности, в зависимости от значений параметров
<var> widerange</var> и <var>tol</var>.
</p>
<ul>
  <li><var>widerange</var> = true : сначала вычисляется разность ( n )
между пикселами двух клипов, потом она пересчитывается по формуле
r = 128 + 128 * pow(n / 255,1 / <var>tol</var>). 
Если <var>tol</var> &lt; 0, 1 / <var>tol</var> считается равным 
0.5.</li>
  <li><var>widerange</var> = false :
    <ul>
      <li><var>tol</var> &lt; 0 : вычисляется модуль разности клипов,
и пересчитывается как r = n / 2 + 128.</li>
      <li><var>tol</var> &gt;= 0 : вычисляется модуль разности клипов,
возвращается 0 если n меньше tol, n - tol в противном случае.
</li>
    </ul>
  </li>
</ul>
<p>Значения по умолчанию : <var>tol</var> = -1, <var>widerange</var> = false.
</p>
<h2><a name="examples"></a>III) Примеры практического использования
(не протестированные достаточно основательно)
</h2>
<p>В этих примерах не получатся в точности такие же результаты, как и в 
исходных фильтрах, работа которых имитируется, кроме того, все это работает
довольно медленно. Кроме множества дополнительных функций, никаких новых
идей.
</p>
<p>Примечания:<br>
- Я слишком ленив чтобы изменять синтаксис каждый раз, особенно в отношении
функционирования mode=2, и в отношении изменений в поведении EdgeMask
( например, теперь уже не нужно использовать Binarize )<br>
- Некоторые фильтры, описанные тут, уже существуют (imagereader, пороги для
сравнения, ...).
</p>
<h4><a name="msharpen"></a>1) MSharpen
</h4>
<pre># Строим EdgeMask от clip1, делаем Binarize и называем результат clip3
# Посредством любого фильтра увеличения резкости (шарп) получаем из clip1 clip2
...
return MaskMerge(clip1, clip2, clip3)
</pre>
<p>Края деталей изображения, содержащегося в clip2, у которых яркость выше
порога, заданного для Binarize заменят исходные значения в clip1.
Еще можно сделать фильтр с какой-нибудь таблично заданной функцией
(лучше всего подходит колоколообразная кривая), использовать его вместо
Binarize, и получить шарпинг взвешенный по яркости границ. Так работает
SmartSmoothHiQ.
</p>
<pre>clip2 = clip1.&lt;EdgeEnhancer&gt;(&lt;parameters&gt;)
#Каналы цветности U и V фильтровать не нужно, а Y нужно
#EdgeMask(&lt;...&gt;, "roberts", Y=3, U=-128, V=-128) работает с яркостями
clip3 = clip1.EdgeMask(15, 60, "roberts", Y=3, U=1, V=1)
return MaskedMerge(clip1, clip2, clip3)</pre>
<h4><a name="msoften"></a>2) MSoften
</h4>
<p>Заменить в предыдущем примере EdgeEnhancer на какой-нибудь 
фильтр для размытия (несколько раз примененный Blur или 
spatialsoftenMMX ) и поставить upper=true чтобы выделить однородные участки.
</p>
<h4><a name="rainbow"></a>3) Устранение "радуги" (как описано  
<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=48167"><cite>здесь</cite></a>
)
</h4>
<p>Внимание, это тоже не супер-эффективное решение.
</p>
<pre>clip2 = clip1 до упора размытый (например deen("m2d") или edeen)
#Берем маску краев по яркости и растягиваем края
# чтобы получились более широкие области в этих местах
clip3 = clip1.EdgeMask(6, "roberts", Y=3, U=1, V=1).Inflate(Y=3, U=1, V=1)
#Теперь возьмем эту маску и применим ее к каналам цветности
clip3 = YtoUV(clip3, clip3).ReduceBy2().Binarize(15, upper=false, Y=1, U=3, V=3)
#Нам надо обработать цветность вокруг краев, но не трогать при этом яркость
return MaskedMerge(clip1, clip2, clip3, Y=1, U=3, V=3)</pre>
<h4><a name="fxtoon"></a>4) Передискретизация в fxtoon
</h4>
<p>Не проверено</p>
<pre>. С помощью tweak затемните картинку или сделайте фильтр, который пропорционально
уменьшит значения яркости. 
-&gt; clip2
. Постройте маску краев изображения. Примените сглаживание (Supersampling).
Примените Binarize с высоким порогом. Сделайте Inflate -&gt; clip3
. Примените более темные пиксели из clip2 в зависимости от значений clip3</pre>
<h4><a name="warpsharp"></a>5) Warpsharp для темных клипов
</h4>
<p>Не проверено
</p>
<pre>. Примените warpsharp -&gt; clip2 (материал для замены)
. Сделайте ограничивающий фильтр по яркости -&gt; clip3 (mask)</pre>
<h4><a name="deinterlacer"></a>6) псевдо - деинтерлейс (проблемы с цветностью 
все равно останутся)</h4>
<p>Не проверено
</p>
<pre>clip2 = clip1.SeparateFields().SelectEven().&lt;Method&gt;Resize(&lt;parameters&gt;)
clip3 = clip1.&lt;CombingDetector&gt;(&lt;parameters&gt;)
return MaskedMerge(clip1, clip2, clip3, Y=3, U=3, V=3)</pre>
<h4><a name="rect_overlay"></a>7) Непрямоугольные наложения
</h4>
<p>На самом деле, делается проще через layer и mask...
</p>
<pre>#Обманем ImageReader, которому нужно целое число кадров в секунду
#В основном исходники все в YUY2/YV12
clip = AviSsource("test.avi").ConvertToYV12().assumefps(fps)
#Загрузим картинку для наложения
image = ImageReader("mask.bmp", 0, clip.framecount()-1, 24, use_DevIl=false)
#Предположим что черный должен быть прозрачным
#С другими цветами все будет сложнее (*)
masktemp = imageYV12.Binarize(17, upper=false, Y=3)
#Подгоним маску, сделанную по яркости, к каналам цветности
mask = Mask.FitY2UV()
#Теперь у нас есть маска, в которой записано, что нужно оставить...
#Заменим все что нужно по маске
MaskedMerge(clip, image, mask, Y=3, U=3, V=3)
#* можно сделать так: mask = OverlayMask(image, image.BlankClip("$xxxxxx"), 1, 1)
</pre>
<h4><a name="backgournd"></a>8) Замена фона
</h4>
<p>Этот пример работает лучше в  RGB. Чтобы избежать типичных проблем с шумом
или артефактами сжатия, лучше применить размытие к клипу и к фону.
</p>
<pre>source = AviSource("overlay.avi").AssumeFPS(24)
#Размытие исходного изображения 
clip = source.Blur(1.58).Blur(1.58).Blur(1.58)
#Загрузим фон
bgnd = ImageReader("bgnd.ebmp", 0, clip.framecount()-1, 24, 
use_DevIl=false)
#Загрузим новый фон
new = ImageReader("new.ebmp", 0, clip.framecount()-1, 24, 
use_DevIl=false)
#фильтр, делающий mask = (clip~overlay?)
mask = OverlayMask(clip, overlay.ConvertToYV12(), 10, 10)
MaskedMerge(source, new.ConvertToYV12(), mask, Y=3, U=3, V=3)</pre>
<h4><a name="mftoon"></a>9) K-mfToon
</h4>
<p>Я должен включить больше информации, в том числе исходные ссылки
и постинги, но сейчас я думаю что автор исходного mfToon, mf (mf@onthanet.net)
не сильно обидится на это.
<br>
Результат функции, содержащейся в K-mfToon.avs должен быть идентичным с
результатом исходного mftoon.avs (оба включены в дистрибутив), но она вдвое быстрее.
<br>
Для использования функций:<br>
- Из mfToon:<br>
  . включите плагины "MaskTools", "warsharp", "awarsharp"
</p>
<h2><a name="todo"></a>IV) Планы на будущее
</h2>
<p>Пока нет, все зависит от реакции общественности.<br>
</p>
<h2><a name="disclaimer"></a>V) Предупреждение
</h2>
<p>Этот плагин распространяется в соответствии с лицензией GPL.
Перед использованием ознакомьтесь с ее условиями.
<br>
Также рекомендуется учитывать интересы окружающих и не думать так : "я знаю как это 
сделать, но никому не скажу".
<br>
<br>
И наконец : я протестировал очень небольшую часть из всех возможных применений
этого пакета (думаю что 5% - несколько часов на отладку ;-). Это значит, что
ваши сообщения об ошибках будут _очень_ ценны (обратное тоже верно - я про отсутствие
таких сообщений...)
</p>
<h2><a name="revisions"></a>VI) Версии
</h2>
<p>1.5.8 - 8 Авг 2005</p><ul>  <li>Добавлен DEdgeMask2.</li></ul>
<p>1.5.7</p><ul>  <li>Добавлен YUY2LUT.</li></ul><p>1.5.6</p><ul> 
 <li>Исправлена работа с цветностью в YV12LUTxy.</li></ul>
v1.5.5 - 6 Ноя 2004<ul>  <li>Версия с Binarize заработала;<br>
    для Pentium4 с HT.</li></ul>
<p>v1.5.4 - 14 Окт 2004</p><ul>
  <li>Переработана часть фильтров.
</li></ul>
<p>1.5.2 - 1.5.3</p><ul>  <li>?</li></ul><p>1.5.1</p><ul>
  <li>Полностью переписана документация (Спасибо Вилберту).</li>
  <li>DEdgeMask теперь допускает не только целые делители. Однако, если
делитель все-таки целочисленный, фильтр *должен* работать быстрее.</li>  
<li>DEdgeMask получил обратно параметр "setdivisor", но он теперь нужен 
только для совместимости с уже написанными скриптами.</li>  
<li>YV12LUTxy : новый фильтр, написанный по идее Didee. Символ "y" 
представляет значение пиксела второго клипа.
</li></ul>
<p>1.4.16
</p>
<ul>
  <li>Исправлено : в Logic "min" &amp; "max" работали неправильно.</li>
  <li>Исправлено : в Logic &amp; Subtract не работали режимы MMX &amp; iSSE 
оптимизаций, вследствие глупой ошибки.</li>
</ul>
<p>1.4.15.3</p>
<ul>
  <li>Добавлен RGBLUT : работает как YV12LUT ( только вместо R, G и B используются Y, U 
и V ).</li>
  <li>Кроме того, можно задавать AMP-файл ( из Фотошопа ).</li>
</ul>
<p>1.4.15.2</p>
<ul>
  <li>Устранена ошибка в YV12LUT. Как всегда, глупая...</li>
  <li>В YV12LUT добавлены операторы сравнения и логические
 ( &lt;, &lt;=, &gt;, &gt;=, 
==, !=, &amp;, !&amp;, |, ° ( xor ) )</li>
  <li>В YV12LUT добавлен тернарный оператор : ? ( как в C )</li>
</ul>
<p>1.4.15.1</p>
<ul>
  <li>В YV12LUT убрана ошибка. Надеюсь, теперь будет работать.</li>
</ul>
<p>1.4.15</p>
<ul>
  <li>Новый фильтр : HysteresyMask. Строит новую маску краев по двум имеющимся.
См. документацию.</li>
</ul>
<p>1.4.14.2</p>
<ul>
  <li>Несколько исправлений относящихся к отрицательным значениям
 Y, U и V ( edgemask,
    dedgemask, motionmask, combmask, logic )</li>
  <li>Несколько исправлений относящихся к использованию
offX / offY / w и h ( в фильтрах maskedmerge, binarize, expand, YV12subtract, yv12lut )</li>
  <li>В YV12LUT убрана ошибка, не позволяющая его использовать с некоторым фильтром.
</li>
  <li>В YV12Convolution теперь можно использовать не только целые коэффициенты.
Но с целыми работает быстрее.
Кроме того, при переполнении ( результате большем 255 или меньшем 0 ),
медленная но верная функция дополнительной обработки приведет результат к
0 и 255 соответственно.</li>
</ul>
<p>1.4.14.1</p>
<ul>
  <li>Исправление в YV12LUT позволяющее использовать отрицательные числа</li>
</ul>
<p>1.4.14</p>
<ul>
  <li>Исправлено : В YV12Layer была ненужная проверка, которая могла прводить к неработоспособности фильтра.</li>
  <li>Исправлено : В DEdgeMask не учитывался порог.</li>
  <li>Исправлено : Фильтр Logic теперь полностью работоспособен, в C и MMX</li>
  <li>Добавлено :  Документация на фильтр Logic</li>
  <li>Добавлено : Два режима для Logic : "Min" и "Max" ( C, MMX, iSSE )</li>
  <li>Добавлено : В DEdgeMask возможность нормализации.</li>
  <li>Исправлено : Документация.</li>
</ul>
<p>1.4.13</p>
<ul>
  <li>Исправлено : ошибка в MotionMask ( последняя строка считалась неверно )</li>
  <li>Оптимизация : MaskedMerge теперь работает одинаково в MMX и C, и 
MMX оптимизация теперь включена по умолчанию.</li>
  <li>Добавлено : В EdgeMask можно использовать ядро Лапласа. См. документацию</li>
  <li>Добавлено : 'Новый' фильтр, DEdgeMask, позволяет задавать свое преобразование
 ( ценой уменьшения скорости )</li>
</ul>
<p>1.4.12</p>
<ul>
  <li>Изменение поведения : MotionMask и EdgeMask теперь работают с крайними
пикселами изображения, расширяя маску на эти пикселы.</li>
  <li>Исправлено : Inflate / Inpand / Expand / Deflate, при использовании
отрицательных значений параметров y,u и v вели себя странно.</li>
  <li>Добавлено : В YV12LUT теперь есть функция abs.</li>
</ul>
<p>1.4.11</p>
<ul>
  <li>Исправлено : EdgeMask с MMX и без дает разные результаты. Оптимизация отключена.
    Чтобы включить, ставьте usemmx = true. Работает только для клипов с размерами,
делящимися на 16.</li>
  <li>Исправлено : EdgeMask : первая и последняя строки не всегда считались.</li>
  <li>Исправлено : MaskedMerge : MMX давал более темный результат, чем надо. 
Оптимизация отключена.
    Чтобы включить, ставьте usemmx = true. Работает только для клипов с размерами,
делящимися на 16.
</li>
</ul>
<p>1.4.10</p>
<ul>
  <li>Исправлено : первая и последняя строки неправильно обрабатывались
в  inflate / deflate</li>
  <li>Invert исключен из Masktools, и включен в Ависинт.</li>
</ul>
<p>1.4.9</p>
<ul>
  <li>Новый фильтр : CombMask. Как обычно, читайте документацию.</li>
</ul>
<p>1.4.8</p>
<ul>
  <li>YV12Convolution теперь допускает отрицательные коэффициенты в матрице.
Это позволяет использовать фильтр как детектор краев деталей изображения.</li>
  <li>У YV12Convolution теперь есть новый параметр saturate. Если он равен
true, то значения пикселей принудительно загоняются в диапазон [0..255] во 
время вычислений.</li>
  <li>Новый фильтр : LUT. См. документацию</li>
</ul>
<p>1.4.7</p>
<ul>
  <li>MotionDetection переименован в MotionMask. Я понимаю что это звучит глупо,
зато логично.</li>
  <li>Добавлена проверка размера при использовании MMX в MotionMask</li>
  <li>Немного изменена оптимизация MMX в Binarize.</li>
  <li>Новый фильтр : YV12Convolution. Позволяет делать свертку с матрицей любого
(почти любого) размера. См. документацию.
</li>
</ul>
<p>1.4.6</p>
<ul>
  <li>Определение смены сцен в MotionDetection оптимизировано под iSSE  (
а значит вам понадобится Athlon XP / Pentium IV ). Работает с Athlon XP, 
не тестировано на <br>
Pentium IV, может быть отключено установкой параметра usemmx = false.</li>
  <li>Оптимизировано вычисление движения, без всякого MMX ( просто избежав
необходимости считать одно и то же 3 раза ). Таким образом фильтр должен быть
теперь более или менее в 3 раза быстрее.</li>
</ul>
<p>1.4.5</p>
<ul>
  <li>Добавлен фильтр MotionDetection, пока без MMX или ассемблерных вставок.
См. документацию. Используется идея фильтра Sansgrip (NoMoSmooth) 
и делает маску движения непосредственно в нужном цветовом пространстве.
</li>
</ul>
<p>1.4.4</p>
<ul>
  <li>Восстановлена оптимизация MMX в MaskedMerge</li>
  <li>Осуществлен возврат к оптимизации от Kurosu в Invert</li>
</ul>
<p>1.4.3</p>
<ul>
  <li>Сделаны некоторые оптимизации под MMX ( binarize, invert )</li>
  <li>Исправлены некоторые оптимизации под MMX ( это в основном значит что
некоторые MMX оптимизации были отключены ). Теперь будет работать под P4.</li>
</ul>
<p>1.4.2</p>
<ul>
  <li>Исправлены ошибки в inpand / expand / inflate / deflate </li>
</ul>
<p>1.4.1
</p>
<ul>
  <li>Исправлена страшная ошибка "multiple instances of a filter with different 
functions needed"</li>
</ul>
<p>1.4.0
</p>
<ul>
  <li>Добавлен экспериментальный фильтр LUT. Не тестировано, отлажу потом.</li>
</ul>
<p>1.3.0 (версия для внутреннего употребления)
</p>
<ul>
  <li>Сделана доступной для использования функция FitPlane 
(ее все равно слишком много если надо изменить размер только
одной плоскости), которая раньше была недокументированной.
Еще добавлена функция FastFitPlane (соответствующие FitPlane теперь практически
бесполезны)</li>
  <li>Теперь допускается задание области обработки для нескольких фильтров,
однако это вряд ли приведет к заметному ускорению обработки.</li>
  <li>Подправлен YV12Layer (в основном неиспользуемые режимы "Darken"/"Lighten")</li>
  <li>Добавлена функция OverlayMask, которая сравнивает 2 клипа, и выдает
маску по одинаковым их частям. (медленно и далеко от совершенства).</li>
</ul>
<p>1.2.0 (версия для внутреннего употребления)
</p>
<ul>
  <li>YV12Layer: больше нет бесполезных преобразований в RGB32!
Все примерно как в Arithmetic (только третий клип не нужен), так что здесь все нормально...</li>
  <li>YV12Substract: а почему только C-шная версия ? 
Маски явно недостаточно используются в Ависинте |-[</li>
</ul>
<p>1.1.0 (версия для внутреннего употребления)
</p>
<ul>
  <li>Бывшие inflate/deflate теперь называются expand/inpand, и появились
новые функции с теми же именами.
</li>
  <li>Добавлены функции Logic и Arithmetic (не будут работать потому что не отлажены)</li>
  <li>Edgemask теперь использует 4 порога (2 для яркости и 2 для цветности). 
Они нужны чтобы :
установить в 0 или не менять значение, зависящее от первого порога; 
установить в 255 или не менять значение, зависящее от второго порога.</li>
</ul>
<p>1.0.2 (последняя версия - публичные релизы приостановлены):
</p>
<ul>
  <li>Исправлен сдвиг для edgemask при использовании преобразований Собеля
и Робертса (неправильная инструкция MMX )
</li>
  <li>MaskMerge теперь работает (маска очищается перед использованием... 
можно проверить например используя MaskMerge(clip3,clip3))</li>
</ul>
<p>1.0.1: Первоначальный релиз
</p>
<h2><a name="developer"></a>VII) Обзор для разработчиков
</h2>
<p>Пропустите все до цифры V) если вам не интересно разбираться в исходном коде.
<br>
<br>
Исходники представляют собой простой проект VC++ 6.
Каждый фильтр лежит в своем собственном каталоге, где находится h-файл,
нужный для интерфейса, исходники интерфейсного класса, исходники 
функций-обработчиков и их h-файлы. Например EdgeMask:<br>
- EdgeMask.h используется интерфейсом чтобы определить, как фильтр
"выглядит", (но в interface.cpp находятся определения соглашений о вызовах
и экспортируемых функций)<br>
- EM_func.h описывает обработчики (у них у всех должны быть одинаковые 
параметры):<br>
  . Line_MMX и Line_C<br>
  . Roberts_MMX и Roberts_C<br>
  . Sobel_MMX и Sobel_C<br>
- EM_func.cpp, как и все &lt;что-то&gt;_func.cpp, содержит реализацию
обработчиков, и иногда их MMX версии.<br>
- EdgeMask.cpp содержит реализацию класса; в конструкторе выбирается
соответствующая функция-обработчик (MMX? C? Roberts? Line? Sobel?) 
и передается как указатель в GetFrame<br>
<br>
Interface.cpp соержит экспортируемые функции и все внешние функции
(AVSValue ... Create_&lt;filter&gt;).<br>
<br>
ChannelMode.cpp определяет модель Channel. Туда может быть добавлен
некий эквивалент функции debugprintf.<br>
<br>
Такой краткий обзор вряд ли поможет всем разработчикам, так же как примеры
V) не помогут пользователям, но это все что есть. Конечно, со временем,
все улучшится, в зависимости от общего успеха идеи. У которой есть один
главный недостаток - время исполнения, что скорее всего приведет к тому,
что использование этого пакета будет не особенно интенсивным, если оно
вообще будет.
</p>
<p><kbd>$English Date: 2005/08/28 12:19:19 $<br>
Русский перевод 04.10.2005 Alexander Nickolsky (anickol@yahoo.com)</kbd>
</p>
</body></html>