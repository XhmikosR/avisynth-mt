<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ru">
<head>
  <meta content="text/html;charset=windows-1251"
 http-equiv="Content-Type">
  <title>SimpleResize</title>
  <link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: simpleresize.htm,v 1.3 2006/12/13 21:01:40 fizick Exp $
-->
</head>
<body>
<h1>SimpleResize</h1>
<h2>Общая информация</h2>
<span style="font-weight: bold;">Автор</span><b>: </b>Tom Barry
<br>
<b>Версия</b><b>:</b> 0.3.3.0
<br>
<b>Загрузка</b><b>:</b> <a
 href="http://mywebpages.comcast.net/trbarry/downloads.htm">http://mywebpages.comcast.net/trbarry/downloads.htm</a><br>
<b>Категория</b><b>:</b> Resizers
<br>
<b>Требования</b><b>:</b> YV12 &amp; YUY2 цветовой формат (Colorspace)
<hr>
<h2>Описание </h2>
SimpleResize&nbsp; - это Avisynth фильтр, который делает очень простую
линейную интерполяцию основанную на 2х опорных точках. <br>
Он не отфильтровывает, т.е. он не будет особо сильно смягчать
изображение..
<p>Функции <code>InterlacedResize</code> и <code>
InterlacedWarpedResize</code> были созданы, чтобы<br>
обрабатывать чересстрочный материал (подробнее - в конце документа).</p>
<p>Главное его преимущество - это то, что он работает немного быстрее некоторых
других фильтров.</p>
<h3><b><b>Для </b></b>использования<b> просто:</b></h3>
<p>В вашем Avisynth файле напишите что-то вроде: </p>
<pre>LoadPlugin("F:\SimpleResize\SimpleResize.dll")
Avisource("D:\wherever\myfile.avi")
SimpleResize(width, height)
</pre>
<p>Конечно замените названия файла и каталогов на имеющиеся у Вас и
подставьте нужные целые значения вместо ширины <var>width</var> и высоты <var>height</var>.
</p>
<p><code>SimpleResize</code> должен работать на всех машинах MMX. Он также
имеет дополнительный код<br>
для SSE2 инструкций, если он запущен на P4 или некоторые SSEMMX инструкции
для P3 и<br>
Athlon, если их используют. Извините, но в моих будущих планах
ничего нет для дальнейшей разработки 3DNow кода.<br>
<br>
</p>
<h3>WarpedResize</h3>
<p><code>WarpedResize</code> также включен в&nbsp; SimpleResize.dll. <code>WarpedResize</code>
делает нелинейное растяжение/сжатие по вертикали и горизонтали. Это
может пригодиться, если вам надо
изменить соотношения сторон видео фрагмента, и у Вас наибольшие искажения
на верхнем/нижнем и боковых краях этого видео фрагмента. <br>
Фильтр находится в процессе разработки и не завершен. Но я его добавил
т.к. потребовалось совсем чуть-чуть изменений в коде, а
производительность фактически не
пострадала. Использовать вот так:</p>
<pre>LoadPlugin("F:\SimpleResize\SimpleResize.dll")
AviSource("D:\wherever\myfile.avi")
WarpedResize(width, height, hWarp, vWarp)
</pre>
<p>где <var>hWarp</var> и <var>vWarp</var>&nbsp; - горизонтальные и
вертикальные коэффициенты деформации (warp factors). Это дробные числа
обычно от 0.8 до 1.3, которые определяют насколько нелинейным должен быть
ваш конечный результат.</p>
<p>Значения выше 1.0 делают кадр растянутым в середине и сжатым по
краям. Значения ниже 1.0 делают обратное. Значение 1.0
производит линейное изменение размера кадра по соответствующей оси, т.е.
тоже самое, если бы вы использовали SimpleResize. Значения, сильно
отличающиеся от 1.0, дают очень странные результаты. См. "Заметки
математикам" ниже.</p>
Одной из причин применения WarpedResize может быть потребность изменить
соотношение сторон видео фрагмента из 16:9 на 4:3 (или наоборот)
без обрезания ценного материала и без показа черных полос по краям.
<p>Пример картинки полученной с использованием <code>WarpedResize</code>
пока можно найти здесь: <a
 href="http://www.trbarry.com/warptest.jpg"><cite>http://www.trbarry.com/warptest.jpg</cite></a>.
Эта картинка была получена из короткого HDTV цифрового видео клипа,
захваченного с разрешением 1280x720 и соотношением сторон 16:9. Затем
она была уменьшена с деформацией (warped) до 640x480 с соотношением
сторон 4:3 следующей командой в скрипте:</p>
<pre>WarpedResize(640,480,1.15,0.95)</pre>
<p>Пример обратного преобразования 4:3 клипа с подгонкой к экрану 16:9
путем изменения размера с деформацией: <a
 href="http://www.trbarry.com/Warptest2.jpg"><cite>http://www.trbarry.com/Warptest2.jpg</cite></a></p>
<h3>Текущие Ограничения для фильтров SimpleResize/WarpedResize</h3>
<p>1) Поддерживается только в цветовом формате YUY2. Используйте
ConvertToYUY2 по мере надобности.</p>
<p>2) Конечная ширина уже НЕ ОБЯЗАТЕЛЬНО должна делиться на 4 без
остатка.</p>
<p>3) Будет выполняться быстрее на машинах SSE2, если конечная ширина в
пикселях будет делиться на 8 без остатка, и если данные начинаются на
границе 8-ми пикселей. Я не знаю, окажет ли какое-либо влияние на это
предшествующие команды типа Clip() или нет.</p>
<p>4) Если кто-то знает как сделать из этого DirectShow-фильтр, я был
бы рад, чтобы со мной поделились. ;-)</p>
<h3>Заметки математикам (и вопросы):<br>
</h3>
<p>Представьте экран, который расположен в пределах от -1.0 до 1.0. Для
упрощения мы будем рассматривать только горизонтальные размеры и правую
часть экрана. Допустим нам надо вычислить конечное значение пикселя в
позиции x, где 0 &lt;= x &lt;=1.</p>
<p>Конечное значение будет исходным для входного экрана с такими же
размерами в позиции s. <br>
Сейчас я просто вычисляю s = (1-w) * x^3 + w * x, где w - это
коэффициент деформации (warp factor), о котором упоминалось выше <br>
(отмечено чуть позже: w = 2 - коэффициент деформации, для совместимости
с первой версией). Эта формула вполне срабатывает и выдает плавные
значения от 0 до 1 без особых искажений, если мы сохраняем w близким к
1.0.</p>
Та же формула отражает работу с левой частью экрана.
<p>Уравнения деформации (warp) разработаны так чтобы:</p>
<p>* Всегда возрастать, но давать результаты от 0 до 1</p>
<p>* Иметь первую производную, не стремящуюся к 0 или бесконечности, по
крайней мере вблизи центра экрана.</p>
<p>* Иметь кривизну (абсолютное значение 2-ой производной) маленькую в
центре и плавно возрастающую при перемещение к краям. Хотелось бы иметь
кривизну равной нулю во всех положениях, если коэффициент деформации
равен 1</p>
<p>Я бы сказал, кривизна просто более или менее отображается абсолютным
значением второй производной. Таким образом, если мы хотим иметь
маленькую кривизну при x = 0, и чтобы она росла по мере того как мы
движемся к краям, какую функцию деформации мы можем
использовать? Вышеприведенная функция уже отражает изменения, внесенные
начиная с версии 0.1, но я до сих пор не уверен, что это наилучший
вариант. </p>
<p>Легко написать еще одну функцию деформации. При этом
производительность не должна пострадать, так как начальные
вычисления&nbsp; коэффициентов происходят во время запуска, заносятся в
таблицу и далее они используются в работе (it's just calculated and
tabled at startup). Далее обработка выполняется с той же скоростью, что
и SimpleResize.</p>
<p>Есть ли у кого какие-то идеи? (И вообще, кого-нибудь эта часть
заинтересовала?)</p>
<h3>InterlacedResize и InterlacedWarpedResize</h3>
<p>Если вам нужно изменить размер кадра чересстрочного видео,
используйте:</p>
<p><code>InterlacedResize</code> (<var>width, height</var>)</p>
<p>или</p>
<p><code>InterlacedWarpedResize</code> (<var>width, height, hWarp, vWarp</var>)</p>
<p>Параметры такие же, как в предыдущих функциях. Функции были созданы,
чтобы обрабатывать чересстрочный видео фрагмент без смешения (blending)
четных/нечетных данных, и, чтобы координаты не перепутывались из-за
четных/нечетных сдвигов линий. Теоретически это может привести к потере
небольших подробностей картинки по вертикали или сбить с толку последующие
функции deinterlace или IVTC, но практически в моих тестах я с такими
проблемами не сталкивался.</p>
<p>Итак, если вы хотите сохранить в своем видео чересстрочность,
используйте эти функции. Если вы уменьшаете размер видео, то вы можете
обнаружить, что сперва стоит попробовать InterlacedResize, прежде чем
идти на гораздо более затратный deinterlacing, и это даст Вам небольшое
преимущество в производительности. Но это все экспериментально. YMMV
(сокр. Your Mileage May Vary - у вас иной подход -
 фраза, произносимая программистами в свое оправдание перед оппонентом
  при наличии существенных расхождений в результатах работы одной и той же программы )</p>
<p> Эта программа - бесплатный софт. Ею можно делиться с другими
      пользователями и изменять согласно версиям номер 2 или выше
      правила GNU General Public License опубликованными Free Software
      Foundation. </p>
<p>И ещё - эта программа Филантропическая. Т.е. если вам она подходит и вы вдруг
захотите наградить автора, то, пожалуйста, пожертвуйте какую-то сумму денег на
Electronic Frontier Foundation. Пожертвование - дело добровольное, а не
принудительное. Я ничего не требую, но это помогло бы нам оградить кибер пространство
от колючей проволоки и прочей фигни. Для
более подробной информации смотрите их веб-страничку на www.eff.org.
</p>
<p><kbd>$English Date: 2005/06/09 20:38:19 $<br>
Русский перевод 09.06.2005 venometal совместно с Turyst04 <a
 href="mailto:Turyst04@nextmail.ru">Turyst04@nextmail.ru</a><br>
 Редакция 03.10.2006 <B>Soroka</B> (lyakh (at) iname com)</kbd></p>
</body>
</html>