<html>
<head>
<title>SimpleResize</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: simpleresize.htm,v 1.1 2010/02/27 14:50:14 wilbertd Exp $ 
-->
</head>
<body>
<h1>SimpleResize</h1>
<h2>Pøehled</h2>
<b>autor:</b> Tom Barry
<br><b>verze:</b> 0.3.3.0
<br><b>stáhnout:</b> <a href="http://www6.impacthosting.com/trbarry/downloads.htm">http://www6.impacthosting.com/trbarry/downloads.htm</a>, 
<a href="http://www.avisynth.org/warpenterprises/">http://www.avisynth.org/warpenterprises/</a><br>
<b>kategorie:</b> Filtry pro zmìnu velikosti
<br><b>požadavky:</b> YV12 &amp; YUY2 Barevné prostøedí
<hr>
<h2>Popis</h2>
SimpleResize je Avisynth filtr, který provede velmi jednoduchou 2 vývodovou (tap) lineární interpolaci. Je nefiltrovaný, což znamená, že moc nezmìkèuje.
<p><code>InterlacedResize</code> &amp; <code> InterlacedWarpedResize</code> jsou navrženy pro práci s prokládaným 
materiálem (více na konci dokumentace).</p>
<p>Jeho hlavní výhodou je, že pobìží o nìco rychleji než jiné.</p>
<h3>Aby jste ho použili prostì:</h3>
<p> použijte ve vašem Avisynth souboru pøíkazy podobné tìmto </p>
<pre>LoadPlugin(&quot;F:\SimpleResize\SimpleResize.dll&quot;)
Avisource(&quot;D:\kdekoli\mujsoubor.avi&quot;)
SimpleResize(width, height)</pre>
<p> Samozøejmì nahraïte jména souboru a složek vašimi vlastními a doplòte 
  celá èísla za <var>width</var> &amp; <var>height</var>. </p>
<p><code>SimpleResize</code> by mìl bìžet na všech MMX strojích. Obsahuje také nìjaký (volitelný)
kód pro SSE2 instrukce k práci na P4 a také nìjaký kód pro SSEMMX  
  k práci na P3 &amp; Athlonech, jestliže je používají. Lituji, ale neplánuji zvláštní kód pro 
  3DNow.</p>
<h3>WarpedResize</h3>
<p><code>WarpedResize</code> je do SimpleResize.dll také zahrnut. <code>WarpedResize</code>
provede nelineární protažení/stlaèení jak v horizontálním tak vertikálním rozmìru. To mùže být užiteèné, 
  když chcete zmìnit pomìr stran video klipu a mít ho nejvíc zdeformovaný 
  nahoøe, dole, a na boèních stranách. Je to pøedevším experimentální filtr, ale pøidal jsem ho, protože 
  jsem potøeboval nìjaké zmìny kódu a ty se témìø nedotkly výkonu. Použijte ho takto:</p>
<pre>LoadPlugin(&quot;F:\SimpleResize\SimpleResize.dll&quot;)
AviSource(&quot;D:\kdekoli\mujsoubor.avi&quot;)
WarpedResize(width, height, hWarp, vWarp)</pre>
<p>kde <var>hWarp</var> &amp; <var>vWarp</var> jsou horizontální 
  a vertikální deformaèní (warp) souèinitele. Jsou to reálná èísla, obvykle mezi 0.8 a 1.3 , které urèují jak nelineární výstup opravdu chcete.</p>
<p>Hodnoty nad 1.0 zpùsobí, že výstupní obraz bude více ve støedu a 
  potlaèen na okrajích. Hodnoty pod 1.0 budou dìlat opak. Zadáním 1.0 pro jeden z nich 
  provede lineární zmìnu velikosti v daném rozmìru, právì jako kdyby jste použili
<code>SimpleResize</code>.
Hodnoty daleko od 1.0 dají nìkteré velmi zvláštní výsledky. Viz. &quot;Poznámky pro 
  Matematiky&quot; níže.</p>
<p>Jeden dùvod pro použití <code>WarpedResize</code> by byl, když máte klip s pomìrem stran 16:9  
  a chcete zmìnit velikost na pomìr stran 4:3 bez vyøíznutí 
  cenných informací nebo bez nutnosti zobrazovat èerné pruhy. (nebo naopak)</p>
<p>Pøíklad obrazu s použitím <code>WarpedResize</code> pro tento úèel je (prozatím) na <a href="http://www.trbarry.com/warptest.jpg"><cite>www.trbarry.com/warptest.jpg</cite></a>. 
  Tento obraz byl z krátké HDTV digitální nahrávky, která mìla rozlišení 1280x720, a pomìr stran 16:9. Byl zmenšen a deformován (warped) na 
  640x480 s pomìrem stran 4:3 , použitím následujícího skriptového pøíkazu:</p>
<pre>WarpedResize(640,480,1.15,0.95))</pre>
<p>Také napøíklad nahrávka 4:3 deformovaná na 16:9 obrazovku vypadá takto <a href="http://www.trbarry.com/Warptest2.jpg"><cite>www.trbarry.com/Warptest2.jpg</cite></a></p>
<h3>Souèasná omezení pro SimpleResize/WarpedResize</h3>
<p>1) V souèasnosti je podporován jen YUY2 barevný režim. Pokud je to potøeba pøidejte napøed pøíkaz ConvertToYuY2.</p>
<p>2) Cílová šíøka už NEMUSÍ být dìlitelná 4 pixely.</p>
<p>3) Pobìží rychleji na SSE2 strojích, pokud bude cílová šíøka dìlitelná 
  8 pixely a pokud data zaèínají na 8 pixelové hranici. Nevím jestli ho døívìjší použití pøíkazu Clip() 
  ovlivní nebo ne.</p>
<p>4) Jestli nìkdo ví, jak z tohoto filtru udìlat DirectShow filtr byl bych rád kdyby se o to se mnou podìlil. ;-)</p>
<h3>Poznámky pro matematiky: (a otázky)</h3>
<p>Pøedstavte si obrazovku s rozmìry od -1.0 do 1.0. Prozatím budeme uvažovat jen 
  horizontální rozmìr a jen pravou polovinu obrazovky. 
  Dejme tomu, že chceme vypoèítat hodnotu výstupního pixelu v místì x, kde 0 &lt;= 
  x &lt;=1.</p>
<p>Výstupní hodnota bude zdrojová hodnota pro vstupní obrazovku se stejnými rozmìry 
  v místì s. Teï prostì vypoèítáme s = (1-w) * x^3 + w * x, kde w 
  je deformaèní (warp) souèinitel zmínìný výše (Pozdìjší poznámka: w = 2 - warp souèinitel, pro kompaktnost s prvním vydáním). 
  Toto provede svou práci a vytváøí plynulá èísla od 0 do jedné, bez velkého pokøivení 
  dokud je w poblíž 1.0. </p>
<p>Stejná formule odráží práci v levé polovinì obrazovky.</p>
<p>Deformaèní rovnice jsou navrženy tak aby:</p>
<p>* Vždy rostly, ale dávaly výsledky od 0 do 1</p>
<p>* Jsme mìli první odvozeninu, která se neblíží k 0 nebo nekoneènu, a pokud možno poblíž støedu obrazovky</p>
<p>* Jsme mìli køivku (absolutní hodnota 2. odvozeniny), která je malá uprostøed a plynule se zvyšuje smìrem ke krajùm. Chtìli bychom køivku,
aby byla kdekoli = 0 když je warp souèinitel = 1</p>
<p>Øekl bych, že køivka je více èi ménì urèena absolutní hodnotou 
  druhé odvozeniny. Takže pokud jsme chtìli malou køivku pøi x = 0 a 
  aby se zvyšovala smìrem k okrajùm, jaká deformaèní (warp) funkce by byla užiteèná? Funkce výše už
reprezentuje zmìnu od V 0.1 , ale stále si nejsem jistý jestli je nejlepší. </p>
<p>Je snadné napsat ještì jednu deformaèní funkci. A pøitom není žádná ztráta výkonu,
protože je to vypoèteno a zaneseno do tabulek pøi spuštìní. Poté  
  to bìží stejnou rychlostí jako SimpleResize.</p>
<p>Má nìkdo nìjaký nápad? (Zajímá nìkoho tato èást?)</p>
<h3>InterlacedResize a InterlacedWarpedResize</h3>
<p>Pokud chcete zmìnit velikost prokládaného zdroje, mùžete použít toto:</p>
<p><code>InterlacedResize</code> (<var>width, height</var>)</p>
<p>nebo</p>
<p><code>InterlacedWarpedResize</code> (<var>width, height, hWarp, vWarp</var>)</p>
<p>Obì funkce mají stejné parametry jako pøedchozí, ale jsou navrženy pro práci s prokládaným zdrojem 
  bez smíchání (blending) dat sudých/lichých polí a bez popletení souøadnic kvùli 
  posunùm sudých/lichých øádkù. Teoreticky mohou ztratit malé množství vertikálních 
  detailù nebo zmást další deinterlaèní nebo IVTC funkce, ale dosud jsem ve svých testech 
  nenašel takové problémy.</p>
<p>Takže pokud zamýšlíte zachovat vaše video v prokládané podobì, urèitì toto použijte. 
  A pokud zmenšujete mùžete si všimnout, že stojí za to provést napøed InterlacedResize pøed 
  nároènìjším odstraòováním prokládání, protože získáte malou výkonovou výhodu. 
  Ale je to stále experimentální. YMMV.
</p>
<p><kbd>$English Date: 2005/06/09 20:43:30 $</kbd></p>
<p><kbd>Èeský pøeklad:30.4.2009</kbd></p>
</body>
</html>
