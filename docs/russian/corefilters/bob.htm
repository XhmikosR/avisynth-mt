<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="ru">
<head>
<meta http-equiv="Content-Language" content="ru">
  <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1251">
  <title>Bob Avisynth Filter</title>
  <link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: bob.htm,v 1.4 2008/09/08 16:43:48 fizick Exp $
-->
</head>
<body>
<h2>
<a name="Bob"></a>Bob
</h2>
<p><code>Bob </code>(<var>clip, float "b", float "c", float "height"</var>)
</p>
<p><code>Bob</code> берет клип и выполняет его bob-деинтерлейсинг
(убирает "гребенку"). Это означает, что он расширяет каждое поле до
размеров полного кадра интерполяцией значений между строками. Верхнее
поле немного сдвигается вверх в сравнении с нижним, так что картинка на
самом деле не прыгает вверх-вниз. Однако, она начинает "мерцать" на
стационарных сценах, так как интерполяция на самом деле не
восстанавливает другое поле достаточно точно.
</p>
<p>Фильтр использует <a href="resize.htm"><code>BicubicResize</code></a>
для этой грязной работы. Вы можете указывать ему значения <i>b</i> и <i>с</i>.
Также вы можете воспользоваться случаем и изменить вертикальное
разрешение параметром <var>height</var>.
</p>
<p>Фильтр bob в действительности не передвигает физическую позицию
поля. Он просто возвращает его на начало. Если Вы просто разделили поля
<tt><a href="separatefields.htm"><code>SeparateFields</code></a></tt>()
то получили 2 кадра половинной высоты: строка 0 стала строкой 0 кадра 0
а строка 1 стала строкой 0 кадра 1.Таким образом строки 0 и 1
располагаются в том же месте! Bob теперь изменяет размер каждого кадра
вдвое но для первого кадра использует исходные строки для четных строк,
а для второго - исходные строки для нечетных строк, в точности как и
полагается. Если бы Вы просто увеличили вдвое&nbsp; высоту каждого кадра
после <a href="separatefields.htm"><code>SeparateFields</code></a>(),
то это бы не сработало как надо, так как физическое расположение полей
смещалось бы.
</p>
<p>Схематически:
<br>
Предположим, что строки 0o, 1o, 2o, 3o, ... являются исходными строками
а 0i, 1i,
2i, 3i, ...&nbsp; - интерполированными строками.
</p>
<p>Исходное состояние
<table border="1" cols="2" width="40%">
  <tbody>
    <tr>
      <td>номер строки<br>
      </td>
      <td>кадр 0</td>
    </tr>
    <tr>
      <td>0)</td>
      <td>0o</td>
    </tr>
    <tr>
      <td>1)</td>
      <td>1o</td>
    </tr>
    <tr>
      <td>2)</td>
      <td>2o</td>
    </tr>
    <tr>
      <td>3)</td>
      <td>3o</td>
    </tr>
  </tbody>
</table>
</p>
<p>Разделили поля
<table border="1" cols="3" width="40%">
  <tbody>
    <tr>
      <td>номер строки</td>
      <td>кадр 0</td>
      <td>кадр 1</td>
    </tr>
    <tr>
      <td>0)</td>
      <td>0o</td>
      <td>1o</td>
    </tr>
    <tr>
      <td>1)</td>
      <td>2o</td>
      <td>3o</td>
    </tr>
  </tbody>
</table>
</p>
<p>Удвоили размер
<table border="1" cols="3" width="40%">
  <tbody>
    <tr>
      <td>номер строки</td>
      <td>кадр 0</td>
      <td>кадр 1</td>
    </tr>
    <tr>
      <td>0)</td>
      <td>0o</td>
      <td>1o</td>
    </tr>
    <tr>
      <td>1)</td>
      <td>1i</td>
      <td>2i</td>
    </tr>
    <tr>
      <td>2)</td>
      <td>2o</td>
      <td>3o</td>
    </tr>
    <tr>
      <td>3)</td>
      <td>3i</td>
      <td>4i</td>
    </tr>
  </tbody>
</table>
</p>
<p>что дает неправильный результат, так как физическое положение поля
изменилось.
</p>
<p>Bob же делает это правильно
<table border="1" cols="3" width="40%">
  <tbody>
    <tr>
      <td>номер строки</td>
      <td>кадр 0</td>
      <td>кадр 1</td>
    </tr>
    <tr>
      <td>0)</td>
      <td>0o</td>
      <td>0i</td>
    </tr>
    <tr>
      <td>1)</td>
      <td>1i</td>
      <td>1o</td>
    </tr>
    <tr>
      <td>2)</td>
      <td>2o</td>
      <td>2i</td>
    </tr>
    <tr>
      <td>3)</td>
      <td>3i</td>
      <td>3o</td>
    </tr>
  </tbody>
</table>
</p>
<h4>Чтобы строго сохранить оригинальные поля и просто заполнить отсутствующие строки.</h4>
<pre>bob(0.0, 1.0)</pre>

<p>Bob(0.0, 1.0) сохраняет оригинальные поля для RGB и YUY2 и сохраняет
канал яркости, но не цветности для YV12.

<p>Коэффициенты фильтра b=0.0 и c=1.0 дают вам 0 при x=1.0/2.0 и 1 при x=0.
Вместе с +/-0.25 смещением происходящим с положением оригинальных полей, 
вы получите очень резкий кубический фильтр с коэффициентами -1/8 5/8 5/8 -1/8 
на отводах x=0.5/1.5 для другого поля.

<p>Однако, так как смещение плоскостей цветности - только 0.125 для yv12, отводы
не приходят на те же самые расстояния.
<a href="http://forum.doom9.org/showthread.php?p=826073#post826073">Обсуждение</a>
</p>
<p><kbd>$English Date: 2006/12/24 13:45:08 $<br>
Русский перевод 14.05.2005 Turyst04 <a
 href="mailto:Turyst04@nextmail.ru">Turyst04@nextmail.ru</a><br>
Обновления 31.12.2006 Fizick http://avisynth.org.ru </kbd></p>
<form><input value="Back" onclick="history.go(-1)" type="button"></form>
</body>
</html>