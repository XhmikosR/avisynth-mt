<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="ru">
<head>
<meta http-equiv="Content-Language" content="ru">
   <meta http-equiv="Content-Type" content="text/html; charset="win-1251">
   <title>Overlay Filter</title>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: overlay.htm,v 1.10 2008/09/28 21:34:12 fizick Exp $
-->
</head>
<body >
<h2>
<a href="#Tone" name="SuperEQ"></a>Overlay - наложение видео
</h2>
<p align="left"><code>Overlay </code>(<var>clip, clip overlay, int ''x'', int ''y'', 
clip ''mask'', float ''opacity'', string ''mode'', bool ''greymask'', string ''output'', bool ''ignore_conditional'', bool
''pc_range''</var>)<br>
  <br>
Фильтр <code>Overlay</code> накладывает один клип поверх другого с возможным смещением
накладываемого клипа, используя различные способы наложения. Кроме того, возможна
настройка прозрачности накладываемого клипа.<br>
  <br>
Исходные клипы могут быть представлены в любом цветовом формате, и также
могут иметь различные цветовые форматы - совместимость клипов здесь не имеет
значения !
Исходные клипы автоматически преобразуются к общему формату YUV
(с непрореженной цветностью), что позволяет получать на выходе фильтра иной
формат цвета, чем тот, который имеется на входе. Это также позволяет
использовать клипы в разных цветовых форматах, они будут автоматически
преобразованы. Тем не менее, не рекомендуется использовать Overlay только для
преобразования цветового представления клипа. Во-первых, для этого есть специальные
фильтры, а во-вторых, Overlay делает это медленнее и чуть менее качественно.
<br>
<br>
Как правило, предполагается что значения пикселов у клипов находятся в диапазоне
от 0 до 255. То есть сигнал не будет автоматически ограничен диапазоном (16-235) стандарта CCIR 601.
Для этого можно использовать фильтр 
<a href="limiter.htm"><code>Limiter</code></a>, уже после применения фильтра Overlay.
<br>
<i><b>Маска тоже должна содержать пикселы в диапазоне 0-255.</b></i> 
Можно использовать
<a href="histogram.htm"><code>гистограмму</code></a> в виде
<code>Histogram</code>("levels"), чтобы посмотреть, как в действительности
распределены цвета в картинке.
Если выяснится, что цвета у маски приведены к стандарту CCIR 601, используйте
<a href="coloryuv.htm"><code>ColorYUV</code></a>(levels=&quot;TV-&gt;PC&quot;)
чтобы восстановить цветовую информацию.<br>
<br>
Если вы точно не уверены в том, что вы делаете, не используйте наложение
с чересстрочным (interlaced) видео &nbsp;
<h4 align="left"><b>Параметры :</b></h4>
<p align="left"><b>clip</b><br>
Это базовый клип - тот <i>на</i> который будет наложено изображение.
&nbsp;
<p align="left"><b>overlay<br>
</b>Это оверлей - клип, который содержит накладываемое изображение. Его 
цветовой формат и размеры по горизонтали и вертикали могут не совпадать
с таковыми у базового клипа.
<p align="left"><b>x</b> и <b>y</b>
<br>Эти параметры задают положение накладываемого клипа относительно базового. Задаются в пикселах,
и могут быть как положительными, так и отрицательными<br>
<i>По умолчанию равны 0.</i>
<p align="left"><b>mask<br>
</b>Это маска - клип, который будет играть роль маски прозрачности для
накладываемого изображения. Маска должна иметь такой же размер, что и оверлей. 
По умолчанию используется только информация о яркости (luma) маски.
Чем темнее маска, тем более прозрачным будет выглядеть накладываемое изображение. 
<br>
<i>Значения по умолчанию здесь нет, но если маска не задана, то считается что
все ее пикселы имеют значение 255.</i>
<p align="left">
<b>opacity<br>
</b>Задает прозрачность накладываемого клипа. Значение можно изменять в диапазоне
от 0.0 до 1.0, где 0.0 означает полную прозрачность, а 1.0 - полную непрозрачность
(если нет маски). Если маска используется, то указанное значение умножается на значение
пиксела маски чтобы получить прозрачность данного пиксела.
<br>
<i>По умолчанию 1.0</i>
<p align="left"><b>mode<br>
</b>Определяет способ наложения клипа.&nbsp;
<table border="1" width="100%">
  <tr>
    <td width="8%"><b>Значение mode</b></td>
    <td width="92%"><b>Описание</b></td>
  </tr>
  <tr>
    <td width="8%">Blend</td>
    <td width="92%">Это способ по умолчанию. При opacity равной 1.0 
и отсутствии маски, оверлей просто накладывается поверх базового клипа.
</td>
  </tr>
  <tr>
    <td width="8%">Add</td>
    <td width="92%">Сложение значений двух клипов. Результат становится
более ярким. Если яркость начинает зашкаливать за стандартные пределы, то
изменяется цвет, и изображение становится более белым (как в RGB).
</td>
  </tr>
  <tr>
    <td width="8%">Subtract</td>
    <td width="92%">Противоположность Add. Делает изображение темнее.</td>
  </tr>
  <tr>
    <td width="8%">Multiply</td>
    <td width="92%">Тоже затемняет изображение, но иначе, чем Subtract.</td>
  </tr>
  <tr>
    <td width="8%">Chroma</td>
    <td width="92%">Накладывает только цветовую составляющую оверлея на 
базовое изображение.</td>
  </tr>
  <tr>
    <td width="8%">Luma</td>
    <td width="92%">Накладывает только яркостную составляющую оверлея на 
базовое изображение.
</td>
  </tr>
  <tr>
    <td width="8%">Lighten</td>
    <td width="92%">Накладывает информацию о яркости оверлея на базовый клип, но
только в тех местах, где оверлей ярче, чем базовое изображение.
</td>
  </tr>
  <tr>
    <td width="8%">Darken</td>
    <td width="92%">Накладывает информацию о яркости на базовый клип, но
только в тех местах, где оверлей темнее, чем базовое изображение.
</td>
  </tr>
  <tr>
    <td width="8%">SoftLight</td>
    <td width="92%">
Осветляет или затемняет базовый клип, в зависимости от уровня яркости
оверлея. Если оверлей темнее, чем клип с luma = 128, базовый клип будет
затемнен. Если оверлей светлее, чем клип с luma = 128, базовый клип будет
осветлен. Это полезно для добавления теней к картинке. Накладывание чисто
черного (чисто белого) цветов приведет к существенному затемнению (осветлению)
изображения, но в результате не получатся чистые черный или белый. Название
режима переводится как "мягкий свет", так оно в действительности и выглядит.
</td>
  </tr>
  <tr>
    <td width="8%">HardLight</td>
    <td width="92%">
Осветляет или затемняет базовый клип, в зависимости от уровня яркости
оверлея. Если оверлей темнее, чем клип с luma = 128, базовый клип будет
затемнен. Если оверлей светлее, чем клип с luma = 128, базовый клип будет
осветлен. Это полезно для добавления теней к картинке. Накладывание чисто
черного (чисто белого) цветов приведет к тому, что на результирующем изображении
в этих местах будет чистый черный (белый) цвет.
Название режима переводится как "жесткий свет", так оно в действительности и выглядит.
</td>
  </tr>
  <tr>
    <td width="8%">Difference</td>
    <td width="92%">
Результат - разность между базовым клипом и оверлеем. Обратите внимание, что
как и в фильтре <a href="subtract.htm">Subtract</a>
отсутствие различий будет выражено как серый цвет, но с яркостью 128 вместо 126. 
Если вам нужна точная разность, используйте режим mode="Subract" или добавьте 
<a href="coloryuv.htm">ColorYUV</a>(off_y=-128).</td>
  </tr>
  <tr>
    <td width="8%">Exclusion</td>
    <td width="92%">
Инвертирует (производит негативное изображение) изображения в зависимости от яркости
оверлея. Если оверлей чисто белый, то в результате получается просто негатив,
если оверлей черный, то ничего не меняется.
</td>
  </tr>
</table>
<p align="left"><i>По умолчанию предполагается Blend</i>
<p align="left"><b>greymask<br>
</b>
Этот параметр определяет, будет ли цветность маски учитываться при расчете
прозрачности. Обычно это так и требуется делать. Внешние фильтры, такие как 
mSharpen или Masktools способны выдавать нужные маски.
<br>
<i>По умолчанию true - включено</i>
<p align="left"><b>output<br>
</b>
Дает возможность задать формат цвета для результирующего клипа.
Допустимые значения таковы :
&quot;YUY2&quot;, &quot;YV12&quot;, &quot;RGB32&quot; и &quot;RGB24&quot;.<br>
<i>По умолчанию формат цвета результата совпадает с форматом цвета
исходного (базового) клипа</i>
<p align="left"><b>ignore_conditional<br>
</b>Заставляет Overlay игнорировать условные вычисления
См. раздел "Условные переменные" руководства.
<br>
<i>По умолчанию false - использовать условные вычисления</i>
<p align="left"><b>pc_range<br>
</b>Если установить этот параметр в true, все внутренние преобразования
из  RGB в YUV и обратно в RGB будут предполагать что яркость (luma) изменяется
от 0 до 255, а не от 16 до 235. Используйте этот параметр только если вы
точно уверены что это вам нужно. Прочтите раздел "Рассуждения о RGB" ниже.
<br>
<i>По умолчанию false - использовать телевизионный диапазон яркости</i>
<h3 align="left">Рассуждения о RGB</h3>
<p align="left">
Этот раздел содержит информацию о том, почему фильтр Overlay 
работает именно так, а не иначе, когда дело касается клипов в формате RGB<br>
Исходные клипы для Overlay могут быть в формате RGB. Но, поскольку вся
внутренняя обработка в Overlay производится в формате YUV, исходный материал
конвертируется. Существует два способа сделать это, и задавая параметр
"pc_range", можно выбрать один из них. Если задать его равным true, то 
диапазон YUV будет расширен с 16-235 (как во всех встроенных конвертерах) до 0-255. 
В следующих случаях это может быть полезно :
<ul>
  <li>
    <p align="left">
При накладывании RGB-клипа с использованием режимов "add", "subtract" и "multiply",
результат будет лучше, поскольку совершенно черные области оверлея не будут 
влиять на результат вовсе (в противном случае совершенно черных областей просто
не будет - к ним везде добавится 16).
</li>
  <li>
    <p align="left">
Если преобразование цветового формата не производится. В противном случае,
например если на входе имеем RGB, а на выходе YUY2, а pc_range=true, то 
диапазон результирующего YUY2 будет неправильным, не соответствующим CCIR 601.</li>
</ul>
<p align="left"><b>Результат в формате RGB</b></p>
<p align="left">Возможно, наилучшим решением будет оставить результат работы
фильтра Overlay в формате YUY2, даже если на входе - RGB, поскольку таким 
образом можно избежать проблем с преобразованиями формата. Тем не менее,
как отмечено выше, при использовании pc_range = true, возможно получение
несовместимого со стандартом изображения. Поправить положение можно 
применением ''ColorYUV(levels="pc->tv")'', что приведет клип в соответствие
со стандартом.</p>
<p align="left"><b>Маска в формате RGB</b></p>
<p align="left">
При использовании маски в формате RGB возможны несколько неожиданные
результаты. Однако если маска только серая (не цветная), и параметр 
greymask = true, то проблем не будет. Надо заметить, что значения пикселов
маски не преобразуются к формату CCIR 601, и автоматически будут в диапазоне
0->255 range, в точности соответствуя значениям RGB.</p>
<p><strong>Использование альфа-канала RGB32</strong></p>
<p>Фильтр Overlay не использует альфа-канал. Если вам нужно именно это,
выделите его из клипа, используя <a href="showalpha.htm"><code>ShowAlpha</code></a>.
Для получения максимально возможного качества, выделите его в формате RGB.</p>
<h3 align="left">Условные переменные</h3>
<p align="left">Глобальные переменные &quot;<i>OL_opacity_offset</i>&quot;,
&quot;<i>OL_x_offset</i>&quot; и &quot;<i>OL_y_offset</i>&quot; вычисляются
при обработке каждого кадра. Их значения можно изменить, используя
<a href="conditionalfilter.htm"><code>FrameEvaluate</code></a>.
Значения этих переменных прибавляются к оригиналу в процессе вычисления
каждого кадра. Так, если задать "x = 100", а глобальную переменную
&quot;<i>OL_x_offset</i>&quot; равной 50, то оверлей будет наложен со
смещением 150.<br>
<br>
Если используются несколько фильтров Overlay в одном скрипте, то 
использование условных переменных может быть запрещено установкой
параметра "ignore_conditional = true".</p>
<p align="left">
Пример условных вычислений можно найти в документации на фильтр
the <a href="conditionalreader.htm"><code>ConditionalReader</code></a>.
</p>
<h3 align="left">Примеры использования</h3>
<p align="left"># Приготовим исходники.</p>
<div align="left">
  <pre align="left">bg = colorbars(512,384).converttoyuy2()
text=blankclip(bg).subtitle(&quot;Colorbars&quot;,size=92,text_color=$ffffff).coloryuv(levels=&quot;tv-&gt;pc&quot;)</pre>
</div>
<p align="left"># Наложим текст тремя разными способами.</p>
<div align="left">
  <pre align="left">overlay(bg, text, x=50, y=20, mode=&quot;subtract&quot;, opacity=0.25)
overlay(text, x=50, y=120, mode=&quot;add&quot;, opacity=0.5)
overlay(text, x=50, y=240, mode=&quot;blend&quot;, opacity=0.7)</pre>
</div>
<p># Наложение на yuy2clip клипа rgbclip с использованием маски в yuy2 (обратите внимание что
яркость маски лежит в диапазоне [0-255]).
<pre>Overlay(yuy2clip, rgbclip, mask = rgbclip.ShowAlpha(&quot;yuy2&quot;))</pre>
<p># что то же самое что и
<pre>mask = rgbclip.ShowAlpha(&quot;rgb&quot;).ConvertToYUY2.ColorYUV(levels=&quot;TV-&gt;PC&quot;)
Overlay(yuy2clip, rgbclip, mask)</pre>
<p># что то же самое что и
<pre>mask = rgbclip.ShowAlpha(&quot;rgb&quot;)
Overlay(yuy2clip, rgbclip, mask)</pre>
<p># Получим среднее арифметическое двух клипов. Например, так можно слить одно
и то же видео, захваченное два раза, с целью уменьшения шума. Обсуждение этого
метода читайте : [<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=28438">здесь</a>].
Пример использования (разумеется, надо убедиться, что два клипа действительно
одинаковы, кадр в кадр, в противном случае можно использовать
<a href="deleteframe.htm">DeleteFrame</a>):</p>
<pre>clip1 = AviSource(&quot;F:\shakira-underneath_your_clothes.avi&quot;)
clip2 = AviSource(&quot;F:\shakira-underneath_your_clothes2.avi&quot;)
Overlay(clip1, clip2, mode=&quot;blend&quot;, opacity=0.5)</pre>

<p># Использование синего (или любого другого цвета) фона в качестве маски.
blue.jpg - синий кадр с субтитрами в черном прямоугольнике.
Этот прямоугольник с субтитрами будет наложен на исходный клип,
в качестве которого в этом примере используется ColorBars:</p>
<pre>testcard = ColorBars()

# получим синюю маску (того же синего оттенка, который используется в ColorBars : R16 G16 B180)
maskclip = BlankClip(testcard, color=$0f0fb4)

# возьмем файл с субтитрами и синим фоном, таким, как указано выше
subs = ImageSource(&quot;F:\TestClips\blue.jpg&quot;).ConvertToRGB32

maskclip = ColorKeyMask(subs, $0f0fb4, 60)

Overlay(testcard, subs, mask=ShowAlpha(maskclip), mode=&quot;blend&quot;, opacity=1)</pre>
<table border="1" width="50%">
  <tr>
    <td width="25%" align="center"><img border="0" src="../pictures/corefilters/overlay_blue.jpg" width="320" height="240"></td>
    <td width="25%" align="center"><img border="0" src="../pictures/corefilters/overlay_subs.png" width="320" height="240"></td>
  </tr>
</table>
<p>Допуск в 60 нужен потому, что синий цвет в jpg файле не везде одинаковый.
Например, рядом с границей черного прямоугольника он имеет значения 
R23 G22 B124, вероятно вследствие артефактов сжатия blue.jpg.</p>

<p>Перемещаем красную (или другого цвета) точку по клипу, с использованием ConditionalReader
(dot.bmp - это красная точка на черном фоне):</p>
<pre>a1 = ColorBars().Trim(0,399)
a2 = ImageSource(&quot;F:\TestClips\dot.bmp&quot;).ConvertToRGB32

# a2.GreyScale делает нам серую точку на черном фоне; Levels превращает точку в белую
mask_clip = Mask(a2, a2.GreyScale.Levels(0, 1, 75, 0, 255))
Overlay(a1, a2, mask=ShowAlpha(mask_clip), y=0, x=0, mode=&quot;blend&quot;, opacity=1)

ConditionalReader(&quot;xoffset.txt&quot;, &quot;ol_x_offset&quot;, false)
ConditionalReader(&quot;yoffset.txt&quot;, &quot;ol_y_offset&quot;, false)</pre>
<p>Сделайте файлы xoffset.txt, содержащий x-координаты и yoffset.txt, содержащий y-координаты
движущейся точки (см. <a href="conditionalreader.htm">ConditionalReader</a>
для справки ), и положите в тот же каталог, где лежит сам скрипт:</p>
<table border="1" width="100%">
  <tr>
    <td width="50%">
      <pre>xoffset.txt

Type int
Default -50

R 0 100 20
I 100 200 20 250
R 200 300 250
I 300 400 250 400</pre>
    </td>
    <td width="50%">
      <pre>yoffset.txt

Type int
Default -50

R 0 100 20
I 100 200 20 350
R 200 300 350
I 300 400 350 40</pre>
    </td>
  </tr>
</table>
<table border="1" width="100%">
  <tr>
    <td width="50%" align="center"><img border="0" src="../pictures/corefilters/overlay_dot.png" width="320" height="240"></td>
    <td width="50%" align="center"><img border="0" src="../pictures/corefilters/overlay_dot2.png" width="320" height="240"></td>
  </tr>
</table>
<p>Точка будет перемещаться по такой траектории : (20,20) -&gt; (250,350) -&gt;
(400,40). NB, можно достичь того же эффекта, используя фильтр Animate.</p>

<h3>Изменения:</h3>
<table border="1" width="100%">
  <tr>
    <td width="8%"> v2.54</td>
    <td width="92%">Первоначальный вариант</td>
  </tr>
</table>

<p align="left"><kbd>$English Date: 2006/12/15 19:29:25 $<br>
Русский перевод 25.05.2005 Alexander Nickolsky (anickol@yahoo.com)<br>
Редакция 27.09.2006 Fizick avisynth.org.ru</kbd></p>
<form>
  <p><input TYPE="Button" VALUE="Back"
onClick="history.go(-1)"></p>
</form>

</body>
</html>
