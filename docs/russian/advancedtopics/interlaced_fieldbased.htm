<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="ru"><head>
  <meta http-equiv="Content-Language" content="ru">
   <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
   
   <title>Interlaced and Field-based video</title><link rel="stylesheet" type="text/css" href="../../avisynth.css"><!-- Automatically generated, don't change: 
$Id: interlaced_fieldbased.htm,v 1.5 2006/12/15 19:59:44 fizick Exp $ 
--></head>
<body style="direction: ltr;">
<h2>Чересстрочное (Interlaced) и основанное на полях (Field-based) видео</h2>
<p>В настоящее время (версии 2.5x и более ранние), AviSynth не имеет
чересстрочного флага (признака), который может быть использован для
чересстрочного видео. Существует флаг для видео, основанного на полях
(полукадрах, с полем в качестве базовой единицы, разделенное на
поля,&nbsp; fieldbased), но в контрасте с тем что Вы могли бы ожидать,
<i> этот флаг не относится к чересстрочному видео.</i> Фактически, любое видео
(прогрессивное или чересстрочное) является основанным на кадрах
(с кадром в качестве базовой единицы, framebased), если только Вы не используете специальные AviSynth фильтры,
чтобы изменить это. Существуют два фильтра, которые превращают
основанное на кадрах видео в основанное на полях:
<a href="../corefilters/separatefields.htm"> SeparateFields</a> и <a href="../corefilters/parity.htm">AssumeFieldBased</a>.</p>
<ul>
  <li>SeparateFields / Weave
    <ul>
      <li>SeparateFields
(разделить поля): Если необходимо (например, когда шумоподавители
требуют прогрессивного видео на входе), Вы можете расщепить
чересстрочные потоки на поля, используя фильтр SeparateFields.
Выходной клип будет иметь удвоенную скорость кадров оригинального клипа.</li>
      <li>Weave
(соединить поля): После приложения пространственного шумоподавителя
(для временных шумоподавителей ситуация немного более
[<a href="http://www.doom9.org/index.html?/capture/postprocessing_avisynth.html">сложная</a>]), 
фильтр Weave может быть использован, чтобы объединить поля снова для производства чересстрочных кадров.</li>
    </ul>
  </li>
  <li>AssumeFieldBased / AssumeFrameBased
    <ul>
      <li>AssumeFieldBased
(принимай основанное на полях): Применение этого клипа имеет
результатом клип, основанный на полях (field-based). Это может быть
полезно при производстве "искусственных" основанных на полях
клипов.</li>
      <li>AssumeFrameBased (принимай основанное на кадрах): Применение этого фильтра имеет результатом клип,
основанный на кадрах (frame-based). Это может быть полезно при производстве "искусственных"
основанных на кадрах клипов.</li>
    </ul>
  </li>
</ul>
<h3>Преобразования цветовых форматов и чересстрочное / основанное на полях видео</h3>
<p>Предположим Вы имеете <b> чересстрочное видео</b>, Вы хотите работать в основанном на полях режиме
(чтобы например применить некоторую фильтрацию) и Вам также необходимо сделать 
преобразование цвета. Нужно ли Вам делать это преобразование
с основанным на кадрах клипом или Вы можете сделать это с основанным на полях клипом? Итак,
это зависит от типа 
<a href="../corefilters/convert.htm"> преобразования цветового формата</a>, которое вы хотите применить:</p>
<p>* YUY2&lt;-&gt;RGB преобразования могут быть сделаны с любым из них. (Заметьте,
что в этом случае, установка interlaced=true/false (чересстрочное да/нет) не влияет ни на что. Она просто игнорируется.)<br>
    * YV12&lt;-&gt;YUY2/RGB преобразования должны быть сделаны с основанным на кадрах клипом (с установкой
<b> interlaced=true</b> ). Выполнение их с основанным на полях клипом приведет к некорректным результатам.
Точная причина этого лежит за пределами рассмотрения данной заметки, но в общем это является следствием того, как 
определен YV12 цветовой формат. Главная проблема - то что цветность совместно используется пикселами двух разных строчек кадра.
Дополнительная информация может быть найдена
<a href="sampling.htm">здесь</a>.</p>
<p>Более опытные пользователи должны рассмотреть следующее. Вообще говоря,
чересстрочное видео имеет части, где нет или мало движения. 
Таким образом, Вы едва ли увидите какие-либо эффекты чересстрочности (также называемые "гребенкой"(combing))
в этих частях. Они могут рассматриваться прогрессивно, 
а при выполнении преобразования YV12&lt;-&gt;YUY2/RGB с прогрессивным видео,
вы должны использовать установку
<b> interlaced=false</b> чтобы получить лучший результат. Является возможным
делать преобразование YV12&lt;-&gt;YUY2/RGB покадрово, переключаясь  между установками
 interlaced=true и interlaced=false. Вот как сделать это (Вам необходимо иметь установленный плагин
 decomb для возможности использовать функцию IsCombed)</p>
<pre>function ConvertHybridToYUY2(clip a, int "threshold", bool "debug")
{
debug = default(debug, false)
global threshold = default(threshold, 20)

b = ConvertToYUY2(a, interlaced=false)
c = ConvertToYUY2(a, interlaced=true)
ConditionalFilter(a, b, c, "IsCombed(threshold)", "equals", "true", show=debug)
}

function ConvertHybridToRGB(clip a, int "threshold", bool "debug")
{
debug = default(debug, false)
global threshold = default(threshold, 20)

b = ConvertToYUY2(a, interlaced=false)
c = ConvertToYUY2(a, interlaced=true)
ConditionalFilter(a, b, c, "IsCombed(threshold)", "equals", "true", show=debug)
}

AviSource("D:\captures\interlaced-clip.avi") # interlaced YV12
#ConvertHybridToYUY2(debug=true)
ConvertHybridToYUY2()</pre>
<p>Однако, оборотная сторона этого подхода то, что это может привести к
 [<a href="http://forum.doom9.org/showthread.php?s=&amp;postid=476199#post476199">бурлению цветности (chroma shimmering)</a>]
  при переходах от кадра с "гребенкой" к прогрессивному (или обратно). Так что это несовершенное решение.</p>
<h3>Преобразование цвета, чересстрочное / основанное на полях видео и флаг чересстрочности (interlaced) программы dvd2avi</h3>
<p>Для более опытных пользователей. Dvd2avi прослеживает, является ли кадр чересстрочным или прогрессивным
 (используя флаг "interlaced"). В принципе, dvd2avi может быть модифицирована, чтобы хранить это в текстовом файле
и AviSynth мог бы читать его покадрово. Однако, это бесполезно. Проблема в том,
что иногда прогрессивное видео закодировано как чересстрочное,
и таким образом детектируется dvd2avi как чересстрочное. В предыдущем разделе объяснялось,
что в этом случае Вы должны использовать interlaced=false при преобразовании
 YV12&lt;-&gt;YUY2/RGB (так как движения нет)
чтобы получить более точные результаты.
<b> Таким образом, для преобразования YV12&lt;-&gt;YUY2/RGB важно учесть именно присутствие "гребенки", а не то,
что кадр является чересстрочным.</b></p>
<h3>Изменение порядка полей клипа</h3>
<p>Существуют фильтр <a href="../corefilters/swapfields.htm">SwapFields</a>, который обменивает четные/нечетные поля, и плагин, который обращает доминантность (первенство) поля
[<a href="http://www.geocities.com/siwalters_uk/reversefielddominance.html">ReverseFieldDominance</a>].
Первый изменяет пространственный порядок, а второй - временной порядок.</p>
<h4>Обмен полей:</h4>
<p>перед применением SwapFields:</p>
<table border="1" height="183" width="25%">
  <tbody><tr>
    <td height="20" width="50%">line</td>
    <td height="20" width="50%"> 	frame 0</td>
  </tr>
  <tr>
    <td height="20" width="50%">0</td>
    <td height="20" width="50%"> 	t0</td>
  </tr>
  <tr>
    <td height="20" width="50%">1</td>
    <td height="20" width="50%">b1</td>
  </tr>
  <tr>
    <td height="20" width="50%">2</td>
    <td height="20" width="50%"> 	t2</td>
  </tr>
  <tr>
    <td height="20" width="50%">3</td>
    <td height="20" width="50%"> 	b3</td>
  </tr>
  <tr>
    <td height="21" width="50%">4</td>
    <td height="21" width="50%">t4</td>
  </tr>
  <tr>
    <td height="20" width="50%">5</td>
    <td height="20" width="50%"> 	b5</td>
  </tr>
</tbody></table>
<p>порядок полей (верхнее поле первое (top field first), затем нижнее (bottom) поле):</p>
<table border="1" width="25%">
  <tbody><tr>
    <td width="33%">line</td>
    <td width="33%">field 0</td>
    <td width="33%">field 1</td>
  </tr>
  <tr>
    <td width="33%">0</td>
    <td width="33%"> 	t0</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">1</td>
    <td width="33%">&nbsp;</td>
    <td width="33%"> 	b1</td>
  </tr>
  <tr>
    <td width="33%">2</td>
    <td width="33%"> 	t2</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">3</td>
    <td width="33%">&nbsp;</td>
    <td width="33%"> 	b3</td>
  </tr>
  <tr>
    <td width="33%">4</td>
    <td width="33%">t4</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">5</td>
    <td width="33%">&nbsp;</td>
    <td width="33%"> 	b5</td>
  </tr>
</tbody></table>
<p>после применения SwapFields:</p>
<table border="1" height="183" width="25%">
  <tbody><tr>
    <td height="20" width="50%">line</td>
    <td height="20" width="50%"> 	frame 0</td>
  </tr>
  <tr>
    <td height="20" width="50%">0</td>
    <td height="20" width="50%">b1</td>
  </tr>
  <tr>
    <td height="20" width="50%">1</td>
    <td height="20" width="50%">t0</td>
  </tr>
  <tr>
    <td height="20" width="50%">2</td>
    <td height="20" width="50%">b3</td>
  </tr>
  <tr>
    <td height="20" width="50%">3</td>
    <td height="20" width="50%">t2</td>
  </tr>
  <tr>
    <td height="21" width="50%">4</td>
    <td height="21" width="50%">b5</td>
  </tr>
  <tr>
    <td height="20" width="50%">5</td>
    <td height="20" width="50%">t4</td>
  </tr>
</tbody></table>
<p>порядок полей (верхнее поле первое (top field first), затем нижнее (bottom) поле):</p>
<table border="1" width="25%">
  <tbody><tr>
    <td width="33%">line</td>
    <td width="33%">field 0</td>
    <td width="33%">field 1</td>
  </tr>
  <tr>
    <td width="33%">0</td>
    <td width="33%">&nbsp;</td>
    <td width="33%">b1</td>
  </tr>
  <tr>
    <td width="33%">1</td>
    <td width="33%">t0</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">2</td>
    <td width="33%">&nbsp;</td>
    <td width="33%">b3</td>
  </tr>
  <tr>
    <td width="33%">3</td>
    <td width="33%">t2</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">4</td>
    <td width="33%">&nbsp;</td>
    <td width="33%">b5</td>
  </tr>
  <tr>
    <td width="33%">5</td>
    <td width="33%">t4</td>
    <td width="33%">&nbsp;</td>
  </tr>
</tbody></table>
<p>Заметьте, что четные и нечетные строки обменены, так что Вы можете назвать верхнее поле нижним полем, и наоборот.</p>
<h4>Обращение доминантности поля (Reversing field dominance):</h4>
<p>перед обращением доминантности поля:</p>
<table border="1" height="183" width="25%">
  <tbody><tr>
    <td height="20" width="50%">line</td>
    <td height="20" width="50%"> 	frame 0</td>
  </tr>
  <tr>
    <td height="20" width="50%">0</td>
    <td height="20" width="50%"> 	t0</td>
  </tr>
  <tr>
    <td height="20" width="50%">1</td>
    <td height="20" width="50%"> 	b1</td>
  </tr>
  <tr>
    <td height="20" width="50%">2</td>
    <td height="20" width="50%"> 	t2</td>
  </tr>
  <tr>
    <td height="20" width="50%">3</td>
    <td height="20" width="50%"> 	b3</td>
  </tr>
  <tr>
    <td height="21" width="50%">4</td>
    <td height="21" width="50%">t4</td>
  </tr>
  <tr>
    <td height="20" width="50%">5</td>
    <td height="20" width="50%"> 	b5</td>
  </tr>
</tbody></table>
<p>порядок полей (верхнее поле первое (top field first), затем нижнее (bottom) поле):</p>
<table border="1" width="25%">
  <tbody><tr>
    <td width="33%">line</td>
    <td width="33%">field 0</td>
    <td width="33%">field 1</td>
  </tr>
  <tr>
    <td width="33%">0</td>
    <td width="33%"> 	t0</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">1</td>
    <td width="33%">&nbsp;</td>
    <td width="33%"> 	b1</td>
  </tr>
  <tr>
    <td width="33%">2</td>
    <td width="33%"> 	t2</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">3</td>
    <td width="33%">&nbsp;</td>
    <td width="33%"> 	b3</td>
  </tr>
  <tr>
    <td width="33%">4</td>
    <td width="33%">t4</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">5</td>
    <td width="33%">&nbsp;</td>
    <td width="33%"> 	b5</td>
  </tr>
</tbody></table>
<p>после обращения доминантности полей (предполагая что строки смещены вверх, и последняя дублирована):</p>
<table border="1" height="183" width="25%">
  <tbody><tr>
    <td height="20" width="50%">line</td>
    <td height="20" width="50%"> 	frame 0</td>
  </tr>
  <tr>
    <td height="20" width="50%">0</td>
    <td height="20" width="50%">b1</td>
  </tr>
  <tr>
    <td height="20" width="50%">1</td>
    <td height="20" width="50%">t2</td>
  </tr>
  <tr>
    <td height="20" width="50%">2</td>
    <td height="20" width="50%">b3</td>
  </tr>
  <tr>
    <td height="20" width="50%">3</td>
    <td height="20" width="50%">t4</td>
  </tr>
  <tr>
    <td height="21" width="50%">4</td>
    <td height="21" width="50%">b5</td>
  </tr>
  <tr>
    <td height="20" width="50%">5</td>
    <td height="20" width="50%"> 	b5</td>
  </tr>
</tbody></table>
<p>порядок полей (нижнее поле первое (bottom field first), затем верхнее (top) поле):</p>
<table border="1" width="25%">
  <tbody><tr>
    <td width="33%">line</td>
    <td width="33%">field 0</td>
    <td width="33%">field 1</td>
  </tr>
  <tr>
    <td width="33%">0</td>
    <td width="33%">b1</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">1</td>
    <td width="33%">&nbsp;</td>
    <td width="33%">t2</td>
  </tr>
  <tr>
    <td width="33%">2</td>
    <td width="33%">b3</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">3</td>
    <td width="33%">&nbsp;</td>
    <td width="33%">t4</td>
  </tr>
  <tr>
    <td width="33%">4</td>
    <td width="33%">b5</td>
    <td width="33%">&nbsp;</td>
  </tr>
  <tr>
    <td width="33%">5</td>
    <td width="33%">&nbsp;</td>
    <td width="33%"> 	b5</td>
  </tr>
</tbody></table>
<p>Заметьте, что верхнее и нижнее поля обменены, но четные и нечетные строки не обменены.</p>
<h3>Четность (= порядок) полей в AviSynth</h3>
<p>Если клип является основанным на полях, AviSynth прослеживает четность (parity) каждого поля
 (то есть, является ли оно верхним или нижним полем кадра).
Если клип является основанным на кадрах, AviSynth прослеживает доминантное поле в каждом кадре
 (то есть, какое поле в кадре пришло бы первым если бы они были разделены).</p>
<p>Однако, эта информация не является заведомо корректной, так как полевая информация обычно не хранится в видео файлах
 и фильтры-источники AviSynth просто обычно по умолчанию предполагают нижнее поле первым (bottom field first)
  (за исключением плагина MPEG2Source, который дает это правильно!).</p>
<h3>Про DV / DVD в отношении к доминантности поля</h3>
<p>Доминантность поля не одна и та же для каждого источника. DV (с
чересстрочным содержимым) имеет нижнее поле первым (bottom field
first), в то время как DVD (или CVD/SVCD) имеет верхнее поле первым
(top field first). Таким образом, когда преобразуете один в другой, Вам
необходимо изменить доминантность поля. Это может быть сделано в
AviSynth (смотри выше),
но также и в самом кодировщике (для bff материала подобно DV видео, Вам
необходимо установить флаг Upper field first). Некоторые комментарии по
[<a href="http://forum.doom9.org/showthread.php?s=&amp;postid=410692#post410692">другим методам</a>].</p>
<h3>Ссылки</h3>
<p>[<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=47393">DV / DVD и доминантность поля</a>]<br>
Про [<a href="http://www.lurkertech.com/lg/dominance.html">доминантность поля</a>].<br>
[<a href="http://forum.doom9.org/showthread.php?s=&amp;postid=268353">тема на форуме Doom</a>] про обмененные поля и доминантность поля.<br>
[<a href="http://www.geocities.com/siwalters_uk/reversefielddominance.html">Плагин ReverseFieldDominance</a>]</p>
<p><kbd>$English Date: 2006/12/15 19:29:25 $<br>
Русский перевод 26.05.2005-27.09.2006 Fizick http://avisynth.org.ru</kbd></p>
<form><input value="Back" onclick="history.go(-1)" type="button"></form>
</body></html>