<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ru">
<head>
  <meta content="text/html;charset=windows-1251">
<title>DctFilter</title>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: dctfilter.htm,v 1.2 2006/12/13 21:01:40 fizick Exp $ 
-->
</head>
<body>
<h1>DctFilter</h1>
<h2>Общая информация</h2>
<b>Автор:</b> Tom Barry
<br><b>Версия:</b> 0.0.1.4
<br><b>Загрузка: </b><a href="http://mywebpages.comcast.net/trbarry/downloads.htm">http://mywebpages.comcast.net/trbarry/downloads.htm</a><br>
<b>Категория:</b> Misc Plugins<br>
<b>Требования:</b> &nbsp;
<ul>
  <li>YV12 &amp; YUY2 цветовой формат и размер экрана кратный 16x16</li>
  <li>поддержка SSEMMX</li>
</ul>
<hr>
<h2>Описание</h2>
<p>DctFilter это экспериментальный фильтр, который, для каждого блока 8x8, 
будет делать Дискретное косинусное преобразование (DCT), уменьшать значения выбранных частот,
и затем обращать процесс с обратным дискретным косинусным преобразованием (IDCT).</p>
<h3>Использование</h3>
<p> В Вашем файле Avisynth скрипта используйте примерно такие команды</p>
<pre>Avisource(&quot;D:\wherever\myfile.avi&quot;)
DctFilter(1,1,1,1,1,1,0.5,0)</pre>
<h3> Параметры</h3>
<p>Имеется 8 позиционных параметров с плавающей точкой, все из них 
должны быть указаны в диапазоне (0.0 &lt;= x &lt;= 1.0). Они соответствуют
масштабным факторам для 8 строк и столбцов блоков DCT размера 8x8. 
Самый левый параметр соответствует верхней строчке, левому столбцу. 
Это есть компонент нулевой частоты (DC) преобразования,
он должен всегда быть оставлен 1.0. </p>
<p>В приведенном выше примере самые высокочастотные компоненты в каждой строке и столбце 
  будут занулены, в то время как вторые сверху по частоте будут уполовинены. </p>
<p>Параметры строки и столбца перемножаются, чтобы получить масштабный фактор 
  для каждой из 64 величин в блоке. Так что, если верхняя левая величина была V[0,0], то
в указанном примере мы умножим стоку 6, столбец 6 (V[6,6]) на .5*.5 = .25.</p>
<p>Отметьте, что хотя они выглядят как параметры с плавающей точкой, реально они
имеют только 3 бит точность, так что в действительности используются только величины 
0, 1/8, 1/4, 3/8 ... 1.0. 
Но Вы можете указать любую величину, и она будет округлена к ближайшей из этих.</p>
<h3> DctFilterD - новый с версии 0.0.1.4</h3>
<p>Вместо этого, вы можете использовать DctFilterD(DiagCt). Это работает подобно указанному выше,
  но будет занулять заданное параметром DiagCt число нижних правых диагоналей DCT, 
  оставляя другие величины неизменными. 
  В результирующей матрице 8x8 DCT есть 15 возможных диагоналей. (представьте шахматную доску).
  Параметр DiagCt должен быть целым 1-14, говорящим, как много из этих диагоналей
  должны быть занулены, начиная с нижнего правого угла.</p>
<h3>Комментарии</h3>
<p>Эта новая функция DctFilterD(DiagCt) работает на диагоналях. Она проще и либо зануляет диагонали,
либо оставляет их неизменными.</p>
<p>Так что если вы укажете: </p>
<pre>DctFilterD(4)</pre>
<p>тогда 4 диагонали в нижнем правом углу результата DCT будут установлены в 0. </p>
<p>Я не тестировал это много, но, подобно моим результатам с задаваемыми таблицами квантования,  
  оказывается, что если Вы установите DiagCt очень большим, вы начнете получать краевой шум, 
  что-то подобно волнам (ringing).</p>
<p><kbd>$English Date: 2004/08/13 21:57:25 $<br>
Русский перевод 19.05.2006 Fizick avisynth.org.ru</kbd></p>
</html>