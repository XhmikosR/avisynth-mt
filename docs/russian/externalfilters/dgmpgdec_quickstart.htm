<html lang="ru">
<head>
<meta content="text/html;charset=windows-1251" http-equiv="Content-Type">
<title>DGMPGDec Quick Start Guide</title>
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: dgmpgdec_quickstart.htm,v 1.2 2006/12/13 21:01:40 fizick Exp $ 
-->
</head>
<body>
<h1>Быстрое начало работы с DGMPGDec</h1>
<h2>Общая информация</h2>
<b>авторы:</b>  Graft<br>
<b>версия:</b>  1.4.7<br>
<b>категория:</b> MPEG декодеры (источники)<br>
<b>загрузка:</b>   <a href="http://neuron2.net/dgmpgdec/dgmpgdec.html"> http://neuron2.net/dgmpgdec/dgmpgdec.html</a><br>
<b>требования:</b><br>
<b>лицензия:</b>  GPL
<hr>
<h2>Содержание</h2>
<ul>
	<li><a href="#whatis">Что такое DGMPGDec?</a></li>
	<li><a href="#whatneed">Что нужно для его использования?</a>
	<li><a href="#nowhat">Хорошо. Что дальше?.</a></li>
	<li><a href="#indexfile">Что такое файл индексов и что мне с ним делать?</a></li>
	<li><a href="#lastquest">Круто. Последний вопрос...</a></li>
	<li><a href="#twostep">Почему танго в два шага? Почему я не могу делать все прямо в DGIndex?</a></li>
</ul><p>
<p><hr><p>
<h2><a name="whatis">Что такое DGMPGDec?</a></h2>
	DGMPGDec это для декодирования MPEG. Он используется для декодирования MPEG1 или MPEG2
	потоков из таких источников как VOB'ы из DVD-Video, захваченный транспортный поток (TS),
	*.mpg/*.m2v/*.pva файлы и т.п. Наверное наиболее часто применяется для декодирования VOB'ов из DVD.
<p><hr><p>
<h2><a name="whatneed">Что нужно для его использования?</a></h2>
Вам понадобится DGMPGDec и Avisynth. Для начала возьмите Avisynth
2.5 (или выше) и установите его:
<p><a href=http://sourceforge.net/project/showfiles.php?group_id=57023&package_id=72557>Avisynth 2.5</a><p>
Вы будете использовать DGIndex.exe и DGDecode.dll из поставки DGMPGDec, поэтому распакуйте их из
ZIP-архива и положите их вместе в одну папку.
<p>Если Вы хотите видеть декодированное видео, то Вам понадобится VirtualDub:
<p><a href=http://www.virtualdub.org>Сайт VirtualDub</a><p>
Мы предполагаем, что у Вас есть VOB-файлы которые Вы получили из DVD (использованием
Smart Ripper или подобной программы).
<p><hr><p>
<h2><a name="nowhat">Хорошо. Что дальше?</a></h2>
Запустите DGIndex. Используя File/Open, откройте ваши VOB. Вы должны увидеть видео.
Теперь используйте Audio/Output Method/Demux All Tracks. Это сохранит звук в файл(ы),
когда Вы будете делать проект.
<p>
Теперь выбираете File/Save Project и введите имя для файла индексов (D2V файла), который будет сгенерирован.
Будем считать что ваш VOB имеет имя 'myvob.vob'; Вы можете выбрав имя 'myvob' нажать ввод, потому что DGIndex
сам автоматически добавит '.d2v'. Хорошо. Жмите "Save". Процесс индексирования начнётся и Вы увидите
индикатор, движущийся вдоль линии отсёта времени, который показывает прогресс. Потерпите, если фильм длинный.
Когда процесс окончится, выйдите из DGIndex.
<p><hr><p>

<h2><a name="indexfile"></a>Что такое файл индексов и что мне с ним делать?</h2>
<p>DGIndex создал файл индексов, имеющий название вида *.d2v. Он читается DGDecode'ом, который декодирует MPEG
и отдаёт видео поток. Файл индексов содержит информацию, которая сообщает DGDecode, где расположен каждый кадр и
некоторую другую информацию о каждом кадре.</p>
<p>
Но Вы не можете использовать DGDecode напрямую! Это нужно делать через Avisynth. Мы создадим скрипт myvob.avs,
используя текстовый редактор. Дальше в этом документе я покажу Вам, как настроить DGIndex для автоматического
создания скрипта, но сейчас Вам нужно научиться старым способом. Запишите этот текст в новый текстовый файл,
который Вы делаете, названный 'myvob.avs':<p><tt>
&nbsp;&nbsp;LoadPlugin("...\DGDecode.dll")<br>
&nbsp;&nbsp;MPEG2Source("myvob.d2v")
</tt><p>Замените путь '...' в первой строке на путь, указывающий на DGDecode.dll.
<p>Наконец, используйте VirtualDub чтобы открыть скрипт 'myvob.avs', как будто это простой AVI. Именно так!
Вы получили Ваше видео и Вы можете пользоваться случайным поиском в VirtualDub. Есть ли ещё вкусности?<p><hr><p>
<h2>Конечно, конечно, но что со звуком?</h2>
DGIndex сохранил Ваше аудиодорожки в файл(ы). Они будут иметь расширение ".wav", ".ac3", или ".mpa".
Если у Вас ".wav", Вы можете загрузить его прямо в  VirtualDub. Но Вы также можете использовать Avisynth,
что даст Вам возможности фильтрации аудиопотока.
<p>
Допустим у нас есть ".wav" файл.
Наш Avisynth скрипт будет наподобие этого:
<p><tt>
&nbsp;&nbsp;LoadPlugin("...\DGDecode.dll")<br>
&nbsp;&nbsp;video=MPEG2Source("myvob.d2v")<br>
&nbsp;&nbsp;audio=WAVSource("myvob.wav")<br>
&nbsp;&nbsp;AudioDub(video,audio)
</tt><p>
Теперь когда Вы открыли свой скрипт в VirtualDub, у Вас появилось видео и аудио.
<p>
Мы описали обработку над ".wav" файлом. Вам нужен соответствующий типу источника фильтр.
Используйте WAVSource() для ".wav", MPASource() для ".mpa", AC3Source() для ".ac3", и т.д.
WAVSource() встроен в Avisynth. Другие фильтры могут быть найдены здесь:
<a href=http://www.avisynth.org/warpenterprises>Коллекция фильтров Avisynth.</a>
<p>
Не забывайте использовать LoadPlugin() для загрузки фильтра. И прочитайте документацию
по Avisynth, чтобы узнать как можно избавиться от аудио/видео рассинхронизации, используя
DelayAudio(), и другие полезные функции.
<p><hr><p>
<h2>Ага, а как я могу использовать автоматический генератор скриптов?</h2>
А! А за это нужно доплачивать сверху! Нет, честно не надо.
<p>
Давайте предположим, что у Вас есть скрипт, который Вы всегда используете. Возможно наподобие этого:
<p><tt>
&nbsp;&nbsp;loadplugin("...\DGDecode.dll")<br>
&nbsp;&nbsp;loadplugin("...\Decomb.dll")<br>
&nbsp;&nbsp;mpeg2source("myvob.d2v",cpu=6)<br>
&nbsp;&nbsp;fielddeinterlace()
</tt><p>
Скопируйте это в файл и назовите его 'template.avs'. Далее замените имя D2V файла на __vid__ (тут именно <i>ДВА</i> подчерка до "vid" и два после).
template.avs теперь должен выглядеть примерно так:
<p><tt>
&nbsp;&nbsp;loadplugin("...\DGDecode.dll")<br>
&nbsp;&nbsp;loadplugin("...\Decomb.dll")<br>
&nbsp;&nbsp;mpeg2source("__vid__",cpu=6)<br>
&nbsp;&nbsp;fielddeinterlace()
</tt><p>
Как Вы видите, DGIndex начал использовать это как шаблон и вставляет правильное имя файла
вместо __vid__. Ловко, да? Вы также можете использовать __aud__ создания имени аудио файла;
смотрите помощь к DGIndex для деталей.
<p>
OK, all you have to do now is fire up DGIndex, выбирайте файл своего шаблона через меню
Options/AVS Template, и сохраняйте проект File/Save Project.
Если *.avs файл не создан, то DGIndex создаст его, основываясь на шаблоне! Конечно же
создаётся только однажды, а далее AVS скрипт будет автоматически создаваться каждый раз,
когда Вы сохраняете проект DGIndex.
<p><hr><p>
<a name="lastquest"><h2>Круто. Последний вопрос...</h2></a>
Давай!
<p><hr><p>
<a name="twostep"><h2>Почему танго в два шага? Почему я не могу делать все в DGIndex?</h2></a>
Хороший вопрос! Мы хотим чтобы Ваше видео было доступно из любого приложения, которое Вы считаете удобным.
Конечно же мы не можем включить все возможные функции в DGIndex.
Поэтому мы даём возможность 'поставлять' видео в другие приложения.
Avisynth - это AVI файл сервер. Он создаёт 'поддельный AVI', а приложение считает, что это настоящий AVI, когда
открывает *.avs файл.
<p>
Если Вы просто хотите создать AVI со своим видео - это просто. Открываете AVS в VirtualDub,
выставляете сжатие, и нажимаете Save AVI.
<p>
Есть ещё один способ поставления который называется 'VFAPI', он также поддерживается, но Вы уловили мысль:
мы просто поставляем декодированное MPEG2 видео через DGMPGDec. Приложение-получатель должно работать
не зная, что его обманывают.
<p><hr><p>
<small>Copyright (C) 2004, 2005 Donald A. Graft, All Rights Reserved</small>
<p><kbd>$English Date: 2006/09/18 19:02:03 $<br>
$Russian: Русский перевод 16.05.2006 SCIF scif@iatp.festu.ru scif.net.ru$</kbd></p>
</body></html>