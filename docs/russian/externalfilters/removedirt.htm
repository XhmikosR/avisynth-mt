<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ru">
<head>
<title>RemoveDirt Plugin for Avisynth</title>
  <meta  http-equiv="Content-Type" content="text/html;charset=windows-1251">
<link rel="stylesheet" type="text/css" href="../../avisynth.css">
<!--
Automatically generated, don't change:
$Id: removedirt.htm,v 1.3 2006/12/13 21:01:40 fizick Exp $
-->
</head>

<body>
<h1>RemoveDirt</h1>
<h2>Общая информация</h2>
<b>Автор:</b> Rainer Wittmann (aka kassandro)
<br><b>Версия:</b>   0.6.1<br>
<b>Загрузка:</b>  <a href="http://www.removedirt.de.tf/">http://www.removedirt.de.tf/</a><br>
<b>Категория:</b>  временн<b>ы</b>е сглаживатели  (Temporal Smoothers)<br>
<b>Требования:</b> 
<ul>
  <li>Цветовое пространство YV12 или YUY2</li>
  <li>Поддержка набора инструкций SSEMMX в процессоре</li>
  <li>Ширина и высота клипа должны быть кратны 8</li>
</ul>
<hr>
<h2>Обзор</h2>
<p><code>RemoveDirt</code> – это временной сглаживатель для Avisynth 2.5x.  
Если вам лень читать документацию, используйте его без всяких параметров – для среднестатического клипа это 
уберёт примерно половину грязи без появления заметных искажений (артефактов). Хотя установки по умолчанию достаточно 
умеренны, очень резкие движения могут создать некоторый риск появления артефактов. Впрочем, поскольку постобработка 
(постпроцессинг) убирает все явные несглаженные артефакты, эти редкие явления, как правило, сглажены, кратковременны
и малозаметны для человеческого глаза. 
Различные видеоматериалы существенно отличаются друг от друга, поэтому тонкая подстройка параметров фильтра может 
давать весьма различные результаты. Для контроля настройки имеются два разных отладочных метода. 
Значение параметров лучше всего поясняется принципом работы алгоритма. Если вы не понимаете смысла параметра, не 
меняйте его значения, а задайте вопрос в форуме Doom9, в 
<a href="http://forum.doom9.org/showthread.php?s=&amp;threadid=70856">ветке, посвящённой фильтру <cite>RemoveDirt</cite></a>,
а не посылайте мне письмо.</p>

<p>Никакой автоматический очиститель не сможет полностью убрать грязь без внесения искажений в картинку. 
Качество очистки сильно зависит от количества движения. Для предотвращения появления артефактов необходимо подавлять 
сглаживание в <i>движущихся</i> областях. Перемещающаяся камера, разумеется, это достаточно сложный случай.
Первый и последний кадр клипа не обрабатываются фильтром, и поэтому на резкой смене сцены кадры не будут очищены, т.к.
<code>RemoveDirt</code> использует предыдущий и следующий кадры, которые должны быть достаточно похожи на текущий.

Поскольку <code>RemoveDirt</code>, в отличие от других очистителей, пытается убрать грязь, но никогда не размывает её,
можно посоветовать использовать его вместе с лёгким смягчителем (softener) для оставшейся грязи, чтобы улучшить 
сжимаемость клипа. (в этом случае второй фильтр надо ставить после <code>RemoveDirt</code>). 
Если вы используете DivX 5.1.1, его встроенный препроцессор достаточно хорош для этого, но я бы рекомендовал 
использовать его только в лёгком (<i>light</i>) режиме.

С настройками по умолчанию <code>RemoveDirt</code> вряд ли справится с большими участками грязи, но, как правило, 
убирает много мелких загрязнений и пыли; после фильтра клип должен смотреться существенно чище.</p>

<p><code>RemoveDirt</code> поддерживает два наиболее важных цветовых пространства – YV12 и YUY2. 
Возможно использование других пространств класса YUV, но не RGB (если вам необходимо обработать клип в RGB, пользуйтесь 
встроенным в Avisynth преобразователем ConvertToYUY2).
Ширина и высота клипа должны быть кратны 8.</p> 
<p>Как будет видно из описания принципа работы, <code>RemoveDirt</code> достаточно сложен. Для достижения разумной 
скорости обработки пришлось использовать ассемблер и набор инструкций Intel integer SSE (iSSE) во всех низкоуровневых 
процедурах. Таким образом, для работы необходим процессор с поддержкой iSSE.</p> 

<h2>Установка</h2>
<p>Начиная с версии 0.5, дистрибутив RemoveDirt содержит две версии плагина:
RemoveDirt.dll (динамически подключаемый, небольшого размера) и RemoveDirtS.dll (статически подключаемый и большего 
размера). Для работы первого необходим файл msvcr70.dll; если этого файла нет в папке c:\windows\system или где-либо 
ещё в доступном месте:), вам придётся заменить RemoveDirt.dll на RemoveDirtS.dll в папке для плагинов AviSynth 
(пожалуйста, не держите в ней оба файла; множество лишних dll-файлов замедляет работу любой программы, использующей 
AviSynth). <code>RemoveDirt</code> может использоваться во многих экземплярах внутри одного скрипта; конфликтов с 
другими фильтрами тоже не должно быть.</p> 

<h2>Обнаружение грязи</h2>
<p>1. <b>Грязь или царапина появляются только в одном кадре, а не в последовательности из нескольких кадров.</b> 
Это основной принцип работы любого <i>временн<b>о</b>го сглаживателя</i>.
Таким образом, царапины из-за плохого проектора в одном положении на нескольких подряд кадрах <i>не могут</i> быть 
очищены временным сглаживателем. В RemoveDirt это основное свойство определяется следующим конкретным признаком:
пиксел является <i>потенциальной грязью</i> (помехой), если cf[x,y] не лежит между min(pf[x,y],nf[x,y]) и 
max(pf[x,y],nf[x,y]). Здесь cf[x,y] обозначает яркость пиксела с координатами x,y в текущем кадре, и соответственно
pf[x,y] и nf[x,y] – на предыдущем и следующем кадрах.
Другими словами, потенциальная помеха выскакивает за диапазон между предыдущим и следующим кадрами, является выбросом.
Мы используем атрибут "потенциальная", т.к., к сожалению, не только помехи обладают этим признаком, но и некоторые виды
движения в кадре приводят к такого рода выбросам.
Если не различать эти два случая, фильтрация будет скорее не чистить, а портить клип. Это малоприятное утверждение 
делает создание автоматических очистителей с малым уровнем искажений таким нетривиальным делом.
Крайний пример – движущаяся тонкая чёрная линия на белом фоне. Из-за движения любой чёрный пиксель в текущем кадре 
является белым в соседних кадрах, поэтому, согласно нашему определению, они все являются выбросами.
С другой стороны, если ширина объекта достаточно велика в направлении движения, и если точки этого объекта имеют 
сходные цвета, то они не будут заметно выскакивать за пределы пикселей соседних кадров. Таким образом, с точки зрения 
очистителя, имеется <i>"хорошая"</i> и <i>"плохая"</i> разновидность движения. Попытка очистки "плохого" движения 
приводит к артефактам, а "хорошего" – нет.</p>

<p>2. <b>Если очищаемый блок имеет общую границу с другим блоком, который не был очищен по какой-либо причине, 
процедура чистки не должна слишком увеличивать разницу между прилегающими линиями этих двух блоков</b>, 
в противном случае очистка должна быть признана некорректной и отменена. Другими словами, очищенный блок должен 
достаточно хорошо подходить к неочищенным. (Предполагается, что очистка производится раздельно для прямоугольных блоков 
некоторого размера, в данном случае 8х8 - прим. перев.)
Это задача <i>постобработки</i> (постпроцессинга). Хотя она может выглядеть слишком технической, тем не менее эта идея 
очень помогает избежать неприятных артефактов. Откровенно говоря, я думаю, что автоматичесий очиститель с малым уровнем 
искажений вряд ли можно создать без применения этой идеи. 
Для постобработки <code>RemoveDirt</code> использует параметры <var>pthreshold</var> и <var>cthreshold</var>. 
Если общая разница в яркости двух прилегающих друг к другу линий разных блоков увеличивается более чем на
<var>pthreshold</var>, то очистка блока отменяется. Аналогично происходит, если разница в цвете увеличивается больше 
чем на <var>cthreshold</var>. 
Максимальная разница двух линий из 8 пикселов – 8*255. Если <var>cthreshold</var> превышает эту величину, то 
постобработка для цветности не производится. Для пространства YUY2 постпроцессинг цветности пока не реализован. 
Если и <var>pthreshold</var>, и <var>cthreshold</var> больше максимального значения, постобработка вообще отключена.
Значение по умолчанию для <var>pthreshold</var> равно 20, а для <var>cthreshold</var> по умолчанию равно 
<var>pthreshold</var>, если не сказано иначе.
Очевидно, что постпроцессинг яркости более существенен, чем постпроцессинг цветности. Если 
<var>cthreshold</var> и особенно <var> pthreshold</var> велики, то могут появиться малоприятные блочные искажения, 
наиболее вероятно, в областях с очень слабым контрастом. Конечно, для их появления в клипе при этом должно быть 
достаточно сильное движение. Если вы видите такого рода артефакты, следует уменьшить порог постобработки.
Её имеет смысл вообще запрещать, только если все кадры проверены на отсутствие артефактов. 
По смыслу алогритма постпроцессинга, он включается только если имеется хотя бы один неочищенный блок, и перебирает 
циклически все блоки, пока имеются блоки, для которых он отменяет обработку. Тем не менее работает он достаточно 
эффективно.
Изюминка работы <code>RemoveDirt</code> как раз в том, что определителю движения достаточно найти по крайней мере один, 
а не обязательно все блоки движущегося объекта, остальное сделает алгоритм постпроцессинга.</p> 

<h2>Определение движения</h2>
<p>Любая процедура, позволяющая отличить грязь и шум от движения, может считаться своего рода определителем движения.
С этой точки зрения в предыдущем разделе уже было описано две таких процедуры. Здесь мы рассмотрим общего вида 
определитель движения, независящий от шумов. Основная идея при определении того, является ли блок движущимся, состоит в 
измерении отличия этого блока от соответствующих ему в предыдущем и следующем кадре. Однако, для целей очистки это 
неприменимо, т.к. если разница мала, то и грязи не может быть много. Вместо этого измеряется разница между предыдущим и 
следующим кадром, а не предыдущим и текущим, т.е. для определения движения текущий кадр <i>не используется</i>.
В алгоритме работы <code>RemoveDirt</code> поведение определителя движения контролируется в основном параметром
<var> mthreshold</var>. Отличия блоков изменяются от 0 (одинаковые блоки) до 8*255 (отличие полностью белого и чёрного 
блоков). Если разница превосходит <var>mthreshold</var>, блок помечается как движущийся. Значение по умолчанию
<var>mthreshold</var>=150. Чем выше значение <var>mthreshold</var>, тем больше блоков чистится, но тем выше риск 
появления артефактов. Вдобавок к абсолютному порогу, задаваемому этим параметром, <code>RemoveDirt</code> 
также может использовать адаптивные пороги, меняющиеся от блока к блоку (подробности опущены). Эта опция контролируется 
параметром <var>athreshold</var>: чем выше её значение (по умолчанию 50), тем больше блоков чистится и тем выше риск 
артефактов. Если и <var>mthreshold</var>, и <var>athreshold</var>  &gt; 8*255, то <i>все</i> блоки будут очищены.
При наличии “плохого” движения это создаст море искажений, и использовать это можно только для отдельных диапазонов 
кадров (см. ниже).
Кроме того, есть ещё две переменные, 
<var>dist</var> и <var>tolerance</var>, управляющие определением движения. 
Значения по умолчанию <var>dist</var>=1 и <var>tolerance</var>=12. 
Блок B считается соседним с блоком A, если по горизонтали и вертикали они разделены не более <var>dist</var> блоками.
При <var>dist</var>=0 блок имеет только одного соседа, т.е. себя; при <var>dist</var>=1 – 9 соседей (если он не на краю 
изображения), при <var>dist</var>=2 – 25 и т.д. 
Для каждого блока <code>RemoveDirt</code> подсчитывает число соседних блоков, помеченных как движущиеся, и если их 
процентная доля больше <var>tolerance</var>, то очистка блока не производится. Т.о. для значений по умолчанию
один из 9 ближайших блоков может быть движущимся и это не запретит очистку данного блока (в частности, блок может сам
быть движущимся, но у него должны быть неподвижные соседи). Это разумно, т.к. настоящее движение редко происходит 
только в одном отдельно стоящем маленьком блоке. С другой стороны, если плотность движущихся блоков больше некоторой, 
то и соседние с ними не должны быть очищены. Это рассуждение оправдывает введение параметров
<var>dist</var> и <var>tolerance</var>. 
Более высокое значение <var>dist</var> уменьшает очистку; более высокое <var>tolerance</var> – увеличивает.
Если <var>tolerance</var> &gt;= 100, то все блоки очищаются.
Со значениями по умолчанию <code>RemoveDirt</code> способен отличить движущуюся тонкую чёрную линию из рассмотренного 
выше примера от простой грязи (если она движется не слишком быстро).

Определителю движения достаточно найти только отдельные участки движущихся областей, остальное сделает постпроцессинг.
Недостаток такого механизма определения движения в том, что он не различает “хорошее” и “плохое” движение. На самом 
деле, хорошее легче определить. Я надеюсь, что когда-нибудь я смогу улучшить эту часть алгоритма.</p>

<p>Рассмотренный выше метод имеет один серьёзный недостаток, а именно: если блок в кадре имеет достаточно большое 
количество грязи, то соответствующие блоки в предыдущем и следующем кадрах будут неправильно отмечены как движущиеся.
Следовательно, если много небольших участков грязи разбросано по последовательно идущим кадрам, то эффективность очистки 
будет уменьшаться. Способ преодолеть эту проблему заключается в том, чтобы брать два соседних кадра, но не текущий, из 
уже очищенной версии клипа. Такого рода <i>двойная обработка</i> может быть реализована скриптом следующего типа:</p>
<pre>input = MPEG2Source(&quot;input.d2v&quot;)
firstpass = RemoveDirt(input)
cleaned = RemoveDirt(input, neighbour=firstpass)</pre>
<p>Здесь <var>neighbour</var> – переменная с типом <i>клип</i> (значение по умолчанию - тот же клип, что и 
обрабатывается на входе). Разумеется, можно городить такую конструкцию и дальше, но скорость выполнения скрипта будет 
сильно уменьшаться. Обычно число очищаемых блоков увеличивается намного менее, чем на 1% за одну такую итерацию, а 
скорость падает вдвое. В принципе, в переменную neighbor можно пихать всё что угодно, <code>RemoveDirt</code> 
не позволяет её использовать, только если формат этого клипа сильно отличается от основного клипа, так что это помешает 
стабильной работе фильтра.</p> 

<h2>Режимы очистки</h2>
<p>В текущей версии <code>RemoveDirt</code> имеются три режима очистки, определяемые параметром <var>mode</var>.<br>
<var>mode</var> = 0 – простейший режим усреднения. Если блок помечен как очищаемый, то каждый его пиксел заменяется 
средним значением соответствующих пикселей в предыдущем и следующем кадрах. В отсутствие постобработки это с большой 
вероятностью приводит к заметным артефактам.<br>
<var>mode</var> = 2 – режим по умолчанию – гораздо умнее и слегка медленнее. Пусть cf[x,y] – яркость пиксела в текущем 
кадре, pf[x,y], nf[x,y] – яркость тех же пикселей в предыдущем и следующем кадрах. Тогда пиксель не изменяется, если
min(pf[x,y],nf[x,y])  &lt;=   cf[x,y] &lt;= max(pf[x,y],nf[x,y]). Если cf[x,y] &lt; min(pf[x,y],nf[x,y]),
то cf[x,y] заменяется на min(pf[x,y],nf[x,y]); и если  cf[x,y] &gt; max(pf[x,y],nf[x,y]), то cf[x,y] заменяется на
max(pf[x,y],nf[x,y]). Цветовые составляющие обрабатываются аналогичным образом. Этот метод я использую всё время, и он, 
по-видимому, приносит наилучший результат. 
<var>mode</var> = 1 – экспериментальный режим, нечто среднее между двумя вышеописанными (ближе ко второму). Наиболее 
сложный и медленный режим. Изначально я надеялся получить лучшую сжимаемость на этом режиме, но пока это не очень 
подтверждается.</p>

<h2>Более высокая скорость обработки чёрно-белых изображений</h2>
<p>Если вам нужно обработать старый фильм, то вполне возможно, что он будет чёрно-белым. В этом случае фильтровать 
цветовые составляющие не требуется и можно сократить время обработки. Этот режим включается заданием
<var>grey</var> = true. В нём цветовые составляющие просто заменяются на постоянное значение 128, что приводит к 
переводу всего клипа в чёрно-белый вид (то же самое делает встроенный фильтр <a 
href="../corefilters/greyscale.htm">greyscale</a>).
<var>grey</var> = true также отключает постобработку цветности, разумеется, бесполезную в этом случае; имеет смысл 
задавать <var>pthreshold</var> несколько меньше чем обычно, например, 30 или 40.</p>

<h2>Отладочный режим</h2>
<p>Для погружения в детали этого режима обращайтесь к 
<a href="../../english/externalfilters/removedirt.htm">английской документации</a>.</p>

<h2>Задание диапазонов</h2>
<p>Как правило, количество грязи в кадрах склонно меняться на протяжении фильма. Например, первые минуты киноленты
обычно более загрязнены, поскольку лента выступает за катушку; кроме того, отдельные особенно грязные кадры
могут попадаться в любом месте. Такая ситуация неоптимально обрабатывается заданием одних и тех же параметров для всего 
фильма. Для работы с разными установками в <code>RemoveDirt</code> предусмотрены файлы диапазонов, числом до 9, 
определяемые переменными <var>range1, range2, ... , range9</var>.
Каждый файл диапазона может иметь свой собственный набор параметров фильтра, к именам которых добавляется цифра в 
конце, соответствующая номеру диапазона. Например, строка
<p>&nbsp;&nbsp;&nbsp; RemoveDirt(range3= "myrange",  mthreshold3=200, athreshold3=300, tolerance3=0, dist3=2)</p>
<p>указывает, что <code>RemoveDirt</code> использует <var>mthreshold</var> = 200, <var>athreshold</var> = 300 и т.д.
для всех кадров в диапазоне, описанном в файле "myrange", который находится в директории скрипта (впрочем, можно задать 
и произвольный путь к файлу). Для остальных кадров используются значения по умолчанию, т.к. ни один из глобальных 
параметров не был переопределён явно. Файл диапазона содержит или отдельные номера кадров, или диапазоны кадров типа
13756-64 (сокращённая запись для 13756-13764).
Номера кадров в файле должны следовать <i>по возрастанию</i>. Это соглашение делает возможным сокращённую запись, как в 
следующем примере (отдельные диапазоны отделяются пробелами):</p> 
<pre>0-43 67 287 9
1211-39 387 1432-544
11780-2833</pre>
<p>Этот диапазон включает следующие кадры: 0-43, 67, 287, 289, 1211-1239, 1387, 1432-1544, 11780-12833.  Если кадр 
попадает в несколько диапазонов (например, в range2 и range4), то используется более старший (т.е. range4).</p> 

<h2>Оптимальное использование</h2>
<p>1. <b> Не обрезайте кадр после RemoveDirt.</b> Современные кодеки делят кадр на блоки 8х8 пикселей 
таким же образом, как и <code>RemoveDirt</code>. Если вы обрезаете число пикселей, не кратное восьми, то блоки 
RemoveDirt будут не совпадать с блоками кодека, что ухудшит сжатие. Соответственно, обрезание на кратное 8 число 
пикселей не повлияет на это, например, 
Crop(8,64,0,-72) можно себе позволить.</p>

<p>2. <b><a href="../corefilters/crop.htm"> Обрезайте только с параметром &quot;align=true&quot;</a>.</b> 
<code>RemoveDirt</code> интенсивно использует инструкции SSE. Если вы обрезаете без выравнивания "align=true", то
<code>RemoveDirt</code>, возможно, будет работать существенно медленнее.
Лучше выполнять обрезку в Avisynth (с заданием такого параметра), а не в DVD2AVI.</p> 

<p>3. <b>Фильмы, преобразованные к телевизионному формату (Telecined), нужно преобразовать обратно перед применением 
RemoveDirt.</b> В таких фильмах вставляются дополнительные поля, чтобы увеличить частоту кадров с
24 к/с до 30 к/с. На таких удвоенных полях основное свойство грязи – неповторяемость в соседних кадрах – перестаёт 
иметь место, и логика фильтра не работает корректно, кроме того, определитель движения тоже путается. (подробнее – в 
английской документации).</p>

<p>4. <b>Ставьте остальные фильтры после RemoveDirt.</b> За исключением упомянутых выше crop и inverse telecine,
другие фильтры следует применять после <code>RemoveDirt</code>, поскольку, как правило, они оказывают отрицательное 
влияние на определение грязи.</p> 

<h2>Сводная таблица всех параметров</h2>
<table border="1" width="85%">
  <tr>
    <td width="20%" align="center"><b>параметр</b></td>
    <td width="20%" align="center"><b>тип</b></td>
    <td width="20%" align="center"><b>значение по умолчанию</b></td>
    <td width="20%" align="center"><b>примечание</b></td>
    <td width="20%" align="center"><b>раздел</b></td>
  </tr>
  <tr>
    <td width="20%">neighbour</td>
    <td width="20%"> 	Clip</td>
    <td width="20%"> основной обрабатываемый клип</td>
    <td width="20%">&nbsp;</td>
    <td width="20%"> Определение движения</td>
  </tr>
  <tr>
    <td width="20%">dist</td>
    <td width="20%">Integer</td>
    <td width="20%">1</td>
    <td width="20%">>=0</td>
    <td width="20%"> Определение движения</td>
  </tr>
  <tr>
    <td width="20%">mthreshold</td>
    <td width="20%">Integer</td>
    <td width="20%">150</td>
    <td width="20%">>=0</td>
    <td width="20%"> Определение движения</td>
  </tr>
  <tr>
    <td width="20%">athreshold</td>
    <td width="20%">Integer</td>
    <td width="20%">50</td>
    <td width="20%">&nbsp;</td>
    <td width="20%"> Определение движения</td>
  </tr>
  <tr>
    <td width="20%">pthreshold</td>
    <td width="20%">Integer</td>
    <td width="20%">20</td>
    <td width="20%">>=0</td>
    <td width="20%"> Определение грязи</td>
  </tr>
  <tr>
    <td width="20%">cthreshold</td>
    <td width="20%">Integer</td>
    <td width="20%">pthreshold</td>
    <td width="20%">>=0, только для YV12</td>
    <td width="20%"> Определение грязи</td>
  </tr>
  <tr>
    <td width="20%">tolerance</td>
    <td width="20%">Integer</td>
    <td width="20%">12</td>
    <td width="20%">0&lt;=tolerance&lt;=100</td>
    <td width="20%"> Определение движения</td>
  </tr>
  <tr>
    <td width="20%">mode</td>
    <td width="20%">Integer</td>
    <td width="20%">2</td>
    <td width="20%">только 0,1,2</td>
    <td width="20%">Режимы очистки</td>
  </tr>
  <tr>
    <td width="20%">grey</td>
    <td width="20%">Boolean</td>
    <td width="20%">false</td>
    <td width="20%">&nbsp;</td>
    <td width="20%"> Чёрно-белое кино</td>
  </tr>
  <tr>
    <td width="20%">debug</td>
    <td width="20%">Boolean</td>
    <td width="20%">false</td>
    <td width="20%">&nbsp;</td>
    <td width="20%"> Отладка</td>
  </tr>
  <tr>
    <td width="20%">show</td>
    <td width="20%">Integer</td>
    <td width="20%">0</td>
    <td width="20%">только 0,1,2, только YUY2</td>
    <td width="20%"> Отладка</td>
  </tr>
</table>
<p>Все эти параметры могут задаваться для файлов диапазонов путём дописывания номера диапазона к имени параметра.
Например, <i>mode5</i> задаёт режим очистки для диапазона range5.</p>

<h2>RemoveDirt.ini</h2>
<p>Для такого богатого параметрами фильтра, как <code>RemoveDirt</code> (вместе с параметрами для файлов диапазонов их 
число может превышать 100), и с учётом того, что настройки сильно зависят от характера клипа, желательно иметь больше 
одного комплекта настроек по умолчанию. Вместо того, чтобы жёстко запрограммировать их заранее, эти установки по 
умолчанию записаны в файле RemoveDirt.ini. 
Если вы напишете в скрипте <code>RemoveDirt(default="anime")</code>, то фильтр будет пытаться отыскать файл
RemoveDirt.ini в директории скрипта, и если не находит, то вываливается с ошибкой (разумеется, этот файл нужен только
при использовании параметра <var>default</var>). Затем в этои файле ищется строка <i>anime</i>, и если не находится, то 
тоже выдаётся ошибка. В конце концов, читаются все переменные <b>после</b> строки <i>anime</i> и берутся в качестве 
значений по умолчанию. Формат строки такой: <var>имя переменной = значение</var>. Если переменная типа строки, то её 
значение должно быть заключено в кавычки, и не должно содержать кавычек внутри. Если в строке появляется символ 
комментария # (вне пределов строковой переменной), то остаток строки после него игнорируется. Пример файла
RemoveDirt.ini:</p> 
<pre>clensing # экстремальная очистка, только для отдельных кадров, заданных в clensing.rmd 
range1 = &quot;clensing.rmd&quot;
pthreshold1 = 5000
mthreshold1 = 5000 
grey = false 
bw # чёрно-белый режим
grey = true 
pthreshold = 20 
mthreshold =180
anime # режим для аниме
pthreshold = 40 
cthreshold = 30
mthreshold = 200 </pre>
<p>Приведённый RemoveDirt.ini описывает три режима по умолчанию: <b><i>clensing</i></b>,
<b><i>bw</i></b>, <b><i>anime</i></b>. Режим clensing определяет первый файл clensing.rmd диапазона range1 и задаёт
<var>pthreshold1</var> и <var>mthreshold1</var> так, что все пиксели в кадрах, заданных в clensing.rmd, подвергаются 
очистке. Для остальных кадров задаются параметры <var>grey</var> = false, <var>pthreshold</var> = 20, 
<var>mthreshold</var> = 180 and <var>cthreshold</var> = 30, так как эти параметры заданы после строки clensing. 
Для прочих параметров берутся значения по умолчанию. Если вызвать <code> RemoveDirt(default="bw")</code>, то 
используется <var>grey</var> = true, <var>pthreshold</var>d = 20, <var>mthreshold</var> =180 и 
<var>cthreshold</var> = 30 (очевидно, <var>cthreshold</var> игнорируется, т.к. обработка чёрно-белая). 
Если вызвать <code>RemoveDirt(default= "anime")</code>, используется <var>pthreshold</var>= 40, 
<var>cthreshold</var> = 30 и <var>mthreshold</var> = 200. Если в файле содержатся синтаксические ошибки, то фильтр
выдаёт ошибку с номером первой неправильной строки.</p>

<h2>ImproveSceneSwitch</h2>
<p>По смыслу работы алгоритма, <code> RemoveDirt</code> не может делать очистку на резких сменах сцен. С другой 
стороны, как правило, на таких сменах сцен кадры кодируются как ключевые, и если в таком кадре осталось много грязи, то 
сжатие пострадает. Это проблема большинства временнЫх фильтров.
<code>ImproveSceneSwitch</code> – это простой фильтр для исправления ситуации. Ключевым в нём является разница
d(n) между кадрами n и n+1. Фильтр основан на SSE инструкции <i>psadbw</i>; в пространстве YV12 сравниваются только 
яркостные компоненты, иначе и цветовые тоже. 
Если <var>field</var> = 0 (по умолчанию), то для вычисления d(n) используется целый кадр; 
если <var>field</var> = 1, то только верхнее поле, если <var>field</var> = 2 – только нижнее (этот параметр важен для 
фильтров деинтерлейса типа  AlignFields).
Мы называем резкой сменой сцены между кадрами  n и n+1 ситуацию, когда d(n) > ratio*d(n-1) и
d(n)>ratio*d(n+1). Здесь ratio – целочисленная переменная больше единицы (по умолчанию 7, максимум 100), определяющая 
чувствительность фильтра к сменам сцен.
Далее, если у нас есть последовательность кадров n-1,n,n+1,n+2, и между n и n+1 происходит смена сцены, то фильтр 
<code>ImproveSceneSwitch</code> заменяет её на последовательность n-1,n-1,n+2,n+2. 
Конечно, такое дублирование кадров должно происходить только на действительно резких сменах сцен, и тогда зритель вряд 
ли его заметит.
<code>ImproveSceneSwitch</code> используется следующим образом:<br>
<br>
&nbsp;&nbsp;&nbsp;
<code>ImproveSceneSwitch</code>  (<var>clip, orig, ratio = integer, extrapolate = boolean,
first = boolean, last = boolean, field=0,1,2, debug = boolean</var>)&nbsp;<br>
<br>
Здесь <var> orig</var> - входной клип, а <var> clip</var> – результат работы какого-либо временного фильтра, который 
надо обработать описанным образом. <var>orig</var> используется только для определения резких смен сцены.
Вспышки и подобные эффекты, характерные для музыкальных клипов, могут ввести фильтр в заблуждение – для таких 
видеоматериалов его не стоит применять или же надо задавать большую величину ratio (&gt; 10).
По умолчанию, и последний кадр перед, и первый кадр после смены сцены заменяются соответственно на предпоследний и 
второй. Для некоторых фильтров нужно менять только один из них, для этого можно отключать замену параметрами
<var> first</var> и <var>last</var>. Если <var>first</var> = false, то первый кадр после смены сцены не заменяется 
вторым, и аналогично при <var>last</var> = false последний кадр не заменяется предпоследним.
По умолчанию <var>first</var> = true и <var>last</var> = true.
Пример использования <code>ImproveSceneSwitch</code>:</p>
<pre>input = MPEG2Source(&quot;input.d2v&quot;)
dein = RemoveDirt(input)
ImproveSceneSwitch(dein, input)</pre>
<p>By Rainer Wittmann &quot;gorw at gmx.de&quot;</p>
<p><kbd>$English Date: 2004/08/17 20:31:19 $<br>
Русский перевод 10.06.2005 Eugene Vasiliev (eugvas<span>&#64;</span>mccme.ru)</kbd></p>
</body>
</html>