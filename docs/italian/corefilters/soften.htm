<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>SpatialSoften / TemporalSoften Avisynth Filter</title>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
</head>
<body >
<h2>
<a NAME="Soften"></a>SpatialSoften
/ TemporalSoften
</h2>
<p><code>SpatialSoften </code>(<var>clip, int radius, int luma_threshold, int
chroma_threshold</var>)<br>
  <code>TemporalSoften </code>(<var>clip, int radius, int luma_threshold, int
chroma_threshold, int "scenechange", int "mode"</var>)
<p>I filtri <code>SpatialSoften</code> e <code>TemporalSoften</code> tolgono il 
  rumore dal video miscelando selettivamente i pixels. Questi filtri possono fare 
  miracoli ed è vivamente consigliato provarli. Ma essi possono anche eliminare 
  piccoli dettagli se si settano troppo forti , per cui non conviene strafare. 
  In più sono molto lenti, in special modo se usati con un raggio <var>(radius) 
  </var>, molto ampio, sicchè non attivateli finchè tutto il resto non è a posto. 
<p><code>SpatialSoften</code> sostituisce nel frame ogni campione con la media 
  dei campioni vicini che differiscono da quello centrale di non pi&ugrave; di 
  un certo valore di soglia ( threshold). "Vicini&quot; significa lontani non 
  pi&ugrave; di <var>radius</var> pixels sia in direzione x che y . La soglia 
  usata &egrave; <var>luma_threshold</var> per i campioni Y (intensit&agrave;) 
  , e <var>chroma_threshold</var> per i campioni U e V (colore) . 
<p><code>TemporalSoften</code> è simile, eccetto che cerca lo stesso pixel nei 
  frames adiacenti, anzichè pixels adiacenti nello stesso frame. Sono esaminati 
  tutti i frames dentro al <var>radius</var>. TQuesto filtro non sembra essere 
  così efficace quanto <code>SpatialSoften</code>. 
<p>Siete incoraggiati a giocherellare con i parametri per farvi un'idea di quello 
  che fanno--ad esempio settando uno dei 3 parametri ad un valore molto alto pur 
  lasciando gli altri bassi, e vedere cosa succede. Si noti che settando uno qualsiasi 
  dei 3 parametri = 0 il filtro diverrà una palla al piede pur non facendo nulla. 
  <input type="Button" value="Indietro"
onClick="history.go(-1)" name="Button">

<p><code>TemporalSoften</code> opera uno smoothing separato su luma e chroma , 
  mentre <code>SpatialSoften</code> opera uno smoothing solo se sia luma che chroma 
  hanno superato la soglia. 
<p>I filtri <code>SpatialSoften</code> e <code>TemporalSoften</code> lavorano 
  solo con input YUY2 . Usare <code><a href="convert.htm">ConvertToYUY2</a></code> 
  se l'input non &egrave; YUY2. 
<p>Notare che se si usa AviSynth <em>v2.04</em> o superiori, non c'&egrave; pi&ugrave; 
  bisogno del plugin TemporalSoften2 , il TemporalSoften interno &egrave; stato 
  integrato con questa funzionalit&agrave;. 
<p>Ad iniziare dalla<em> v2.50</em>, sono state aggiunte a <code>TemporalSoften</code> 
  2 opzioni:
<ul>
  <li> Un parametro opzionale <var>mode</var><i>=2</i> : Ha una nuova e migliore 
    modalità di miscelazione dei frames e fornisce maggior qualità. Ed è anche 
    più veloce. Necessita di ISSE. <var>mode=1</var> è il valore di default, e 
    funziona come prima. </li>
  <li> E stato aggiunto il parametro opzionale <var>scenechange=n</var> : Usando 
    questo parametro si evita di miscelare quando c'è un cambio di scena. 'n' 
    definisce il cambiamento massimo dei pixel tra i frames. Valori buoni per 
    'n' sono compresi tra 5 e 30. Necessita di ISSE.</li>
</ul>
<p>Per cominciare provate: <code>TemporalSoften</code>(4,4,8,15,2)</p>
<p><kbd>$Date: 2004/10/03 21:26:00 $</kbd>
</p>
<form>
</form>
</body>
</html>
