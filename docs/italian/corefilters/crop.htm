<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Crop / CropBottom Avisynth Filter</title>
   <link rel="stylesheet" type="text/css" href="../../avisynth.css">
</head>
<body >
<h2>
<a NAME="Crop"></a>Crop
/ CropBottom
</h2>
<p><code>Crop </code>(<var>clip, int left, int top, int width, int height,
bool &quot;align</var>&quot;)<br>
  <code>Crop </code>(<var>clip, int left, int top, int -right, int -bottom,
bool &quot;align&quot;</var>)<br>
  <code>CropBottom </code>(<var>clip, int count, bool align</var>)
<p><code>Crop</code> taglia i pixels in eccesso in ogni frame. 
<p>Se il video ha una risoluzione di 720x480, e si vuole ridurlo a 352x240 per 
  ottenere un VideoCD, ecco il modo corretto di farlo: 
<pre># <b>Conversione da CCIR601 a VCD, conservando la corretta aspect ratio</b>
ReduceBy2
Crop(4,0,352,240)</pre>
Vedere <a href="convert.htm">filtri di conversione del colorspace</a> per le limitazioni 
dovute all'uso di diversi colorspaces. 
<p>Se si introducono valori negativi in <var>width</var> ed <var>height</var> 
  questi sono trattati come offsets. Ad esempio: 
<pre># Crop di 16 pixels tutto intorno all'immagine, indipendentemente dalla dimensione 
  della stessa:
Crop(16,16,-16,-16)</pre>
<p>In <em>v2.53</em> &egrave; stata aggiunta una opzione <var>align</var> (false 
  di default):<br>
  Croppare un'immagine YUY2/RGB32 &egrave; sempre mod4 (4 bytes). Tuttavia, leggendo 
  x bytes (x= int), &egrave; pi&ugrave; veloce quando la lettura &egrave; allineata 
  al modx della memoria. MMX/SSE prediligono un allineamento di 8-byte mentre 
  SSE2 di 16-byte. Se i dati NON sono allineati , ogni operazione di read/write 
  operation viene ritardata di almeno 4 cycles. Per questo motivo le immagini 
  sono sempre allineate mod16 quando vengono create da AviSynth.<br>
  <br>
  Se un'immagine &egrave; stata croppata, a volte viene memorizzata disallineata 
  in memoria - &quot;align = true&quot; copia l'intero frame dalla posizione di 
  meria disallineata ad una allineata. Se la penalizzazione dovuta al filtro successivo 
  &egrave; maggiore di quella dovuta alla copia completa dell'immagine, usando 
  &quot;align=true&quot; si ottirne maggior velocit&agrave;. In special modo se 
  i filtri successivi sono degli smoothers.<br>
  <br>
  La sintassi alternativa<code> CropBottom</code> è utile per tagliare porcheria 
  al fondo si una clip catturata da VHS. Rimuove <var>count</var> linee dal fondo 
  di ogni frame. </p>
<p>Per preservare la struttura dei dati propria di altri colorspaces, si dovrebbero 
  usare alcuni accorgimenti. Se non si seguono, non si riceve un messaggio di 
  errore,ma la cosa può creare strani artefatti.
<p>In RGB:<br />
  Larghezza = nessuna restrizione <br />
  Altezza = nessuna restrizione se il video è progressivo <br />
  Altezza = multiplo di 2 (mod-2) se il video è interallacciato <br />
  <br />
  In YUY2:<br />
  Larghezza = mod-2 <br />
  Altezza = nessuna restrizione se il video è progressivo <br />
  Altezza = multiplo di 2 (mod-2) se il video è interallacciato <br />
  <br />
  In YV12:<br />
  Larghezza = mod-2 <br />
  Altezza = mod-2 se il video è progressivo <br />
  Altezza = mod-4 se il video è interallacciato 
<p>NOTA: Le funzioni di resize consentono il cropping di frazioni di pixel , con 
  la conseguenza di un appesantimento dei pixels dei contorni.&nbsp; Queste opzioni 
  si possono usare se le restrizioni delle dimensioni dovute al formato mod-n 
  risultano inadatte. Vedere <a href="resize.htm">Resize Functions</a>. 
<p><kbd>$Date: 2004/09/26 19:49:40 $</kbd></p>
<form>
  <input TYPE="Button" VALUE="Indietro"
onClick="history.go(-1)">
</form>
</body>
</html>
